<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Shooter Pro</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(to bottom, #6a11cb, #fff);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            max-width: 400px;
            height: 90vh;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .header {
            background: #3498db;
            color: white;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 20px 20px 0 0;
            position: relative;
            z-index: 10;
        }

        .header h1 {
            font-size: 1.2em;
        }

        .header-icons {
            display: flex;
            gap: 10px;
        }

        .header-icon {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.3s;
        }

        .header-icon:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .score-container {
            display: flex;
            gap: 15px;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .game-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(to bottom, #f0f8ff, #e6f7ff);
            touch-action: none; /* Prevent default touch behaviors for better control */
        }

        #bubble-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 70%;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-auto-rows: 35px;
            gap: 1px;
            padding: 10px;
            will-change: transform; /* Optimize for animations */
        }

        .bubble {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            color: white;
            font-weight: bold;
            box-shadow: inset 0 -3px 5px rgba(0, 0, 0, 0.2), 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth easing */
            cursor: pointer;
            position: relative;
        }

        .bubble::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }

        .bubble.red { background: linear-gradient(135deg, #ff6b6b, #ff4757); }
        .bubble.blue { background: linear-gradient(135deg, #3498db, #2980b9); }
        .bubble.green { background: linear-gradient(135deg, #2ecc71, #27ae60); }
        .bubble.yellow { background: linear-gradient(135deg, #f1c40f, #f39c12); }
        .bubble.purple { background: linear-gradient(135deg, #9b59b6, #8e44ad); }
        .bubble.bomb { background: linear-gradient(135deg, #e74c3c, #c0392b); animation: pulse 1s infinite; }
        .bubble.bomb::after { content: 'ðŸ’£'; font-size: 12px; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .shooting-bubble {
            transition: none !important;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .shooter-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        #aim-line {
            position: absolute;
            bottom: 95px; /* Adjusted to align with cannon tip */
            left: 50%;
            width: 3px;
            height: 0;
            background: linear-gradient(to top, transparent, rgba(255, 255, 255, 0.8));
            transform-origin: bottom;
            transition: height 0.2s, transform 0.2s;
            pointer-events: none;
            z-index: 5;
            border-radius: 2px;
        }

        #cannon {
            width: 40px;
            height: 60px;
            background: linear-gradient(to top, #2c3e50, #34495e);
            border-radius: 50% 50% 0 0;
            position: relative;
            margin-bottom: 10px;
            transform-origin: bottom center;
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smoother easing for rotation */
        }

        #cannon::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 25px;
            height: 25px;
            background: #2c3e50;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #next-bubble {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-bottom: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        #next-bubble:hover {
            transform: scale(1.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .btn {
            padding: 12px 18px;
            border: none;
            border-radius: 30px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 50px;
            justify-content: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6a11cb, #9b59b6);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: white;
            width: 90%;
            max-height: 80%;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal h2 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .modal p {
            margin-bottom: 15px;
            color: #34495e;
            line-height: 1.5;
        }

        .modal ul {
            text-align: left;
            margin: 10px 0;
        }

        .modal li {
            margin-bottom: 5px;
            color: #34495e;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 30px;
            font-weight: 600;
            cursor: pointer;
            min-width: 120px;
            transition: all 0.3s;
        }

        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            border-radius: 20px;
            color: white;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .challenge-indicator, .combo-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #e74c3c;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
        }

        .combo-indicator {
            top: 50px;
            right: 10px;
            background: #f39c12;
            opacity: 0;
        }

        .combo-indicator.show {
            opacity: 1;
            transform: scale(1.2);
        }

        .level-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #9b59b6;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .high-score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #27ae60;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 11px;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            font-size: 24px;
            color: white;
        }

        .pause-overlay.active {
            display: flex;
        }

        .particles {
            position: absolute;
            pointer-events: none;
            z-index: 20;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: particleExplode 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            box-shadow: 0 0 4px rgba(255,255,255,0.8);
        }

        @keyframes particleExplode {
            0% {
                opacity: 1;
                transform: scale(0) translate(0, 0);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) translate(var(--dx-half), var(--dy-half));
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translate(var(--dx), var(--dy));
            }
        }

        .game-over {
            background: linear-gradient(to bottom, #ff6b6b, #ff4757) !important;
            color: white;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="header">
            <h1><i class="fas fa-bullseye"></i> Bubble Shooter Pro</h1>
            <div class="score-container">
                <div class="score-box">
                    <i class="fas fa-star"></i> <span id="score">0</span>
                </div>
                <div class="score-box">
                    <i class="fas fa-clock"></i> <span id="timer">60</span>s
                </div>
                <div class="score-box">
                    <i class="fas fa-crown"></i> <span id="high-score">0</span>
                </div>
            </div>
            <div class="header-icons">
                <button id="info-btn" class="header-icon" title="Instructions"><i class="fas fa-question-circle"></i></button>
                <button id="pause-btn" class="header-icon" title="Pause"><i class="fas fa-pause"></i></button>
            </div>
        </div>
        
        <div class="game-area">
            <div class="level-indicator">Level: <span id="level">1</span></div>
            <div class="high-score">High Score: <span id="hs-display">0</span></div>
            <div class="challenge-indicator"><i class="fas fa-trophy"></i> Combo x1</div>
            <div class="combo-indicator"><i class="fas fa-fire"></i> Combo!</div>
            
            <div id="bubble-grid"></div>
            <div id="aim-line"></div>
            
            <div class="shooter-area">
                <div id="next-bubble" class="bubble red"></div>
                <div id="cannon"></div>
                <div class="controls">
                    <button id="left-btn" class="btn btn-primary"><i class="fas fa-arrow-left"></i></button>
                    <button id="shoot-btn" class="btn btn-secondary"><i class="fas fa-paper-plane"></i> Shoot</button>
                    <button id="right-btn" class="btn btn-primary"><i class="fas fa-arrow-right"></i></button>
                </div>
            </div>
        </div>
        
        <div id="pause-overlay" class="pause-overlay">
            <div>Paused <i class="fas fa-play"></i></div>
        </div>
        
        <div id="instructions-modal" class="modal">
            <div class="modal-content">
                <h2><i class="fas fa-info-circle"></i> How to Play</h2>
                <p>Aim your cannon and shoot bubbles to match 3 or more of the same color!</p>
                <ul>
                    <li><i class="fas fa-mouse-pointer"></i> Drag or use arrows to aim.</li>
                    <li><i class="fas fa-bullseye"></i> Tap/Shoot to fire.</li>
                    <li><i class="fas fa-star"></i> Pop bubbles for points (10 pts each + combos).</li>
                    <li><i class="fas fa-clock"></i> Clear all before time runs out!</li>
                    <li><i class="fas fa-bomb"></i> Rare bomb bubbles explode 5x5 area.</li>
                    <li><i class="fas fa-fire"></i> Combos multiply score!</li>
                </ul>
                <div class="modal-buttons">
                    <button id="close-instructions" class="modal-btn btn-primary">Got It!</button>
                </div>
            </div>
        </div>
        
        <div id="start-modal" class="modal">
            <div class="modal-content">
                <h2><i class="fas fa-rocket"></i> Ready to Shoot?</h2>
                <p>Match colors, pop bubbles, and climb the levels!</p>
                <div class="modal-buttons">
                    <button id="start-btn" class="modal-btn btn-primary">Start Game</button>
                </div>
            </div>
        </div>
        
        <div id="game-over-modal" class="modal">
            <div class="modal-content">
                <h2 id="game-result">Game Over</h2>
                <p>Your score: <span id="final-score">0</span></p>
                <p id="challenge-result"></p>
                <div class="modal-buttons">
                    <button id="restart-btn" class="modal-btn btn-primary">Play Again</button>
                </div>
            </div>
        </div>
        
        <div id="loader" class="modal active">
            <div class="spinner"></div>
            <p>Loading Pro Features...</p>
        </div>
    </div>

    <script>
        // Game variables
        let score = 0;
        let highScore = localStorage.getItem('bubbleHighScore') || 0;
        let timer = 60;
        let level = 1;
        let gameActive = false;
        let gamePaused = false;
        let timerInterval;
        let cannonAngle = 180;
        let cannonTargetAngle = 180;
        let angularVelocity = 0;
        let nextBubbleColor;
        let currentBubble = null;
        let bubbles = [];
        let comboMultiplier = 1;
        let comboTimer = null;
        const rows = 12; // Increased for more challenge
        const cols = 8;
        const colors = ['red', 'blue', 'green', 'yellow', 'purple'];
        const bubbleSize = 35;
        const gridPadding = 10;
        const hexOffset = 17.5;
        let cannonPos = { x: 0, y: 0 }; // Will be updated dynamically

        // Audio Context for sound effects
        let audioContext = null;
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            initAudio();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = volume;
            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playShootSound() {
            playSound(800, 0.1, 'square', 0.05);
        }

        function playPopSound() {
            playSound(400, 0.05, 'sawtooth', 0.1);
        }

        function playMatchSound(matches) {
            for (let i = 0; i < matches; i++) {
                setTimeout(() => playPopSound(), i * 50);
            }
        }

        function playBombSound() {
            playSound(200, 0.2, 'triangle', 0.15);
        }

        // Hex neighbors for pointy-top odd-r offset
        function getHexNeighbors(row, col) {
            const dirs = row % 2 === 0 ?
                [[1, 0], [1, -1], [0, -1], [-1, 0], [0, 1], [-1, 1]] :
                [[1, 0], [0, -1], [-1, -1], [-1, 0], [0, 1], [1, 1]];
            const neighbors = [];
            for (let [dr, dc] of dirs) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    neighbors.push([nr, nc]);
                }
            }
            return neighbors;
        }

        // DOM elements
        const gameContainer = document.getElementById('game-container');
        const bubbleGrid = document.getElementById('bubble-grid');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const levelElement = document.getElementById('level');
        const highScoreElement = document.getElementById('hs-display');
        const nextBubbleElement = document.getElementById('next-bubble');
        const cannon = document.getElementById('cannon');
        const aimLine = document.getElementById('aim-line');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const shootBtn = document.getElementById('shoot-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const infoBtn = document.getElementById('info-btn');
        const pauseOverlay = document.getElementById('pause-overlay');
        const startModal = document.getElementById('start-modal');
        const instructionsModal = document.getElementById('instructions-modal');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreElement = document.getElementById('final-score');
        const gameResultElement = document.getElementById('game-result');
        const challengeResultElement = document.getElementById('challenge-result');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const closeInstructions = document.getElementById('close-instructions');
        const loader = document.getElementById('loader');
        const challengeIndicator = document.querySelector('.challenge-indicator');
        const comboIndicator = document.querySelector('.combo-indicator');

        // Update high score display
        highScoreElement.textContent = highScore;
        document.getElementById('high-score').textContent = highScore;

        // Update cannon position dynamically
        function updateCannonPos() {
            const rect = cannon.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            cannonPos.x = rect.left + rect.width / 2 - containerRect.left;
            cannonPos.y = rect.bottom - containerRect.top; // Bottom of cannon
        }

        // Smooth rotation animation loop with angular momentum
        function animateCannon() {
            if (gameActive && !gamePaused) {
                const diff = cannonTargetAngle - cannonAngle;
                const maxAngularSpeed = 8; // Max degrees per frame
                const acceleration = 0.3; // Acceleration towards target
                const friction = 0.92; // Momentum decay (lower = more momentum)

                if (Math.abs(diff) > 0.1) {
                    // Accelerate towards target
                    const accel = Math.sign(diff) * acceleration;
                    angularVelocity += accel;
                    // Clamp velocity
                    angularVelocity = Math.max(-maxAngularSpeed, Math.min(maxAngularSpeed, angularVelocity));
                } else {
                    // Apply friction when at target
                    angularVelocity *= friction;
                }

                // Update angle
                cannonAngle += angularVelocity;
                cannonAngle = Math.max(0, Math.min(180, cannonAngle));

                // Update transform
                cannon.style.transform = `rotate(${cannonAngle}deg)`;
                
                // Update aim line
                const aimDistance = 200;
                const lineLength = aimDistance * Math.cos((cannonAngle - 90) * Math.PI / 180);
                aimLine.style.height = `${Math.abs(lineLength)}px`;
                aimLine.style.transform = `rotate(${cannonAngle}deg) translateX(-50%)`;
            }
            requestAnimationFrame(animateCannon);
        }
        animateCannon(); // Start the loop

        // Initialize game with smooth loading
        function initGame() {
            loader.classList.add('active');
            
            // Reset state
            score = 0;
            timer = 60 + (level - 1) * 5; // Bonus time per level
            gameActive = false;
            gamePaused = false;
            comboMultiplier = 1;
            bubbles = Array.from({ length: rows }, () => Array(cols).fill(null));
            bubbleGrid.innerHTML = '';
            scoreElement.textContent = score;
            timerElement.textContent = timer;
            levelElement.textContent = level;
            challengeIndicator.innerHTML = '<i class="fas fa-trophy"></i> Combo x1';
            comboIndicator.classList.remove('show');
            cannonAngle = 90;
            cannonTargetAngle = 90;
            angularVelocity = 0;
            cannon.style.transform = `rotate(${cannonAngle}deg)`;
            aimLine.style.height = '0';
            
            // Update cannon pos
            setTimeout(updateCannonPos, 100);
            
            // Generate bubbles with progressive density
            generateBubbles();
            setNextBubble();
            
            setTimeout(() => {
                loader.classList.remove('active');
                startModal.classList.add('active');
                gameOverModal.classList.remove('active');
                instructionsModal.classList.remove('active');
                pauseOverlay.classList.remove('active');
                updateCannonPos(); // Ensure position updated
            }, 2000); // Longer load for pro feel
        }

        // Generate bubbles with empty spaces and rare bombs
        function generateBubbles() {
            let density = 0.3 + (level - 1) * 0.05;
            if (density > 0.8) density = 0.8;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (Math.random() < density && row > 2) { // Top rows empty for shooting space
                        const isBomb = Math.random() < 0.05; // 5% bomb chance
                        const color = isBomb ? 'bomb' : colors[Math.floor(Math.random() * colors.length)];
                        bubbles[row][col] = color;
                        createBubbleElement(row, col, color);
                    }
                }
            }
        }

        // Create bubble with hex offset for better visuals
        function createBubbleElement(row, col, color) {
            const bubble = document.createElement('div');
            bubble.className = `bubble ${color}`;
            bubble.dataset.row = row;
            bubble.dataset.col = col;
            bubble.style.gridRow = row + 1;
            bubble.style.gridColumn = col + 1;
            if (row % 2 === 1) bubble.style.transform = 'translateX(17.5px)'; // Hex offset
            bubble.innerHTML = color === 'bomb' ? '' : '<i class="fas fa-circle"></i>';
            bubbleGrid.appendChild(bubble);
            return bubble;
        }

        // Set next bubble, 10% chance for bomb
        function setNextBubble() {
            const isBomb = Math.random() < 0.1;
            nextBubbleColor = isBomb ? 'bomb' : colors[Math.floor(Math.random() * colors.length)];
            nextBubbleElement.className = `bubble ${nextBubbleColor}`;
            nextBubbleElement.innerHTML = isBomb ? 'ðŸ’£' : '<i class="fas fa-circle"></i>';
        }

        // Start game with smooth transition
        function startGame() {
            gameActive = true;
            gamePaused = false;
            startModal.classList.remove('active');
            pauseOverlay.classList.remove('active');
            pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
            updateCannonPos();
            
            // Timer with level-based drain
            timerInterval = setInterval(() => {
                if (!gamePaused) {
                    timer -= (1 + (level - 1) * 0.1);
                    timerElement.textContent = Math.ceil(timer);
                    
                    if (timer <= 0) {
                        endGame(false);
                    }
                    
                    if (timer <= 10) {
                        timerElement.parentElement.classList.add('game-over');
                    } else {
                        timerElement.parentElement.classList.remove('game-over');
                    }
                }
            }, 1000);

            // Combo decay
            comboTimer = setInterval(() => {
                if (comboMultiplier > 1) {
                    comboMultiplier = Math.max(1, comboMultiplier - 0.1);
                    challengeIndicator.innerHTML = `<i class="fas fa-trophy"></i> Combo x${Math.floor(comboMultiplier)}`;
                }
            }, 3000);
        }

        // Pause/unpause
        function togglePause() {
            if (!gameActive) return;
            gamePaused = !gamePaused;
            pauseOverlay.classList.toggle('active', gamePaused);
            pauseBtn.innerHTML = gamePaused ? '<i class="fas fa-play"></i>' : '<i class="fas fa-pause"></i>';
        }

        // End game
        function endGame(isWin) {
            gameActive = false;
            clearInterval(timerInterval);
            clearInterval(comboTimer);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('bubbleHighScore', highScore);
                highScoreElement.textContent = highScore;
                document.getElementById('high-score').textContent = highScore;
            }
            
            gameOverModal.classList.add('active');
            finalScoreElement.textContent = score;
            
            if (isWin) {
                gameResultElement.textContent = 'Level Complete!';
                gameResultElement.style.color = '#27ae60';
                challengeResultElement.textContent = `Advanced to level ${level + 1}!`;
            } else {
                gameResultElement.textContent = 'Time\'s Up!';
                gameResultElement.style.color = '#e74c3c';
                const levelsCleared = Math.floor(score / 1000);
                challengeResultElement.textContent = levelsCleared > 0 ? `Cleared ${levelsCleared} levels!` : 'Keep popping!';
            }
        }

        // Check win (all cleared)
        function checkWinCondition() {
            return bubbles.every(row => row.every(cell => cell === null));
        }

        // Aim calculation (mouse/touch to angle) - Full 180 degrees
        function updateAim(clientX) {
            if (!gameActive || gamePaused) return;
            const rect = gameContainer.getBoundingClientRect();
            const deltaX = (clientX - rect.left) - cannonPos.x;
            const aimDistance = 200; // Pixels up for aim calculation
            const rad = Math.atan2(deltaX, aimDistance);
            cannonTargetAngle = (rad * 180 / Math.PI) + 90;
            cannonTargetAngle = Math.max(0, Math.min(180, cannonTargetAngle));
        }

        // Find snap row in a specific column with hex support
        function findSnapPosition(col, startRow) {
            for (let row = Math.min(startRow, rows - 1); row >= 0; row--) {
                if (bubbles[row][col] === null) {
                    // Check immediate support below
                    const belowNeighbors = row % 2 === 0 ?
                        [[row + 1, col], [row + 1, col - 1]] :
                        [[row + 1, col], [row + 1, col + 1]];
                    let hasSupport = false;
                    for (let [br, bc] of belowNeighbors) {
                        if (br < rows && bc >= 0 && bc < cols && bubbles[br][bc] !== null) {
                            hasSupport = true;
                            break;
                        }
                    }
                    if (hasSupport || row === rows - 1) { // Bottom row always supported
                        return row;
                    }
                }
            }
            return -1;
        }

        // Find best snap position nearby
        function findBestSnap(approxCol, approxRow, posX, posY, gridRelLeft, gridRelTop) {
            let best = { row: -1, col: -1, dist: Infinity };
            for (let dc = -1; dc <= 1; dc++) {
                let tCol = approxCol + dc;
                if (tCol < 0 || tCol >= cols) continue;
                let tRow = findSnapPosition(tCol, approxRow);
                if (tRow !== -1) {
                    let tX = tCol * (bubbleSize + 1) + bubbleSize / 2 + (tRow % 2 === 1 ? hexOffset : 0);
                    let tY = tRow * (bubbleSize + 1) + bubbleSize / 2;
                    let dist = Math.hypot(posX - (gridRelLeft + tX), posY - (gridRelTop + tY));
                    if (dist < best.dist) {
                        best = { row: tRow, col: tCol, dist };
                    }
                }
            }
            return best.row !== -1 ? best : { row: -1, col: -1 };
        }

        // Shoot with animation
        function shootBubble(clientX = null) {
            if (!gameActive || gamePaused || currentBubble) return;
            
            if (clientX !== null) {
                updateAim(clientX);
            }
            playShootSound();
            const angleRad = (cannonAngle - 90) * Math.PI / 180;
            const speed = 8;
            const velocity = { x: Math.sin(angleRad) * speed, y: -Math.cos(angleRad) * speed };
            
            currentBubble = createShootingBubble(nextBubbleColor);
            let pos = { x: cannonPos.x, y: cannonPos.y - 30 };
            currentBubble.style.left = `${pos.x}px`;
            currentBubble.style.top = `${pos.y}px`;

            const containerRect = gameContainer.getBoundingClientRect();
            const gridRect = bubbleGrid.getBoundingClientRect();
            const gridRelLeft = gridRect.left - containerRect.left + gridPadding;
            const gridRelTop = gridRect.top - containerRect.top + gridPadding;
            const containerWidth = gameContainer.offsetWidth;
            
            function animateShoot() {
                pos.x += velocity.x;
                pos.y += velocity.y;
                currentBubble.style.left = `${pos.x}px`;
                currentBubble.style.top = `${pos.y}px`;
                
                // Wall bounce - relative
                if (pos.x < gridPadding || pos.x > containerWidth - gridPadding) {
                    velocity.x *= -1;
                    pos.x = Math.max(gridPadding, Math.min(pos.x, containerWidth - gridPadding));
                }
                
                // Ceiling bounce (simplified)
                if (pos.y < 50) {
                    velocity.y *= -0.8; // Dampen
                    pos.y = 50;
                }
                
                // Detect collision with grid
                const relX = pos.x - gridRelLeft;
                const relY = pos.y - gridRelTop;
                const gridCol = Math.floor(relX / (bubbleSize + 1));
                const gridRow = Math.floor(relY / (bubbleSize + 1));
                
                if (gridRow >= 0 && gridRow < rows && gridCol >= 0 && gridCol < cols && relY > 0) {
                    // Find best snap
                    const snapPos = findBestSnap(gridCol, Math.max(0, gridRow), pos.x, pos.y, gridRelLeft, gridRelTop);
                    if (snapPos.row !== -1) {
                        const {row: snapRow, col: snapCol} = snapPos;
                        placeBubble(snapRow, snapCol, nextBubbleColor);
                        // Animate snap
                        const snapX = snapCol * (bubbleSize + 1) + bubbleSize / 2 + (snapRow % 2 === 1 ? hexOffset : 0);
                        const snapY = snapRow * (bubbleSize + 1) + bubbleSize / 2;
                        currentBubble.style.transition = 'all 0.2s ease-out';
                        currentBubble.style.left = `${gridRelLeft + snapX}px`;
                        currentBubble.style.top = `${gridRelTop + snapY}px`;
                        setTimeout(() => {
                            currentBubble.remove();
                            currentBubble = null;
                            checkMatches(snapRow, snapCol);
                            setNextBubble();
                            
                            if (checkWinCondition()) {
                                level++;
                                levelElement.textContent = level;
                                timer += 30;
                                setTimeout(() => {
                                    bubbleGrid.innerHTML = '';
                                    generateBubbles();
                                }, 1500);
                            }
                        }, 200);
                        return;
                    }
                }
                
                if (Math.abs(velocity.y) > 0.5) { // Continue if not too slow
                    requestAnimationFrame(animateShoot);
                } else {
                    // Miss - remove
                    currentBubble.remove();
                    currentBubble = null;
                    setNextBubble();
                }
            }
            requestAnimationFrame(animateShoot);
        }

        // Place bubble in grid
        function placeBubble(row, col, color) {
            bubbles[row][col] = color;
            createBubbleElement(row, col, color);
        }

        // Enhanced matching with flood fill using hex neighbors and falling
        function checkMatches(startRow, startCol) {
            const color = bubbles[startRow][startCol];
            if (!color || color === 'bomb') return handleBomb(startRow, startCol);
            
            const visited = Array(rows).fill().map(() => Array(cols).fill(false));
            const matches = [];
            
            function floodFill(r, c) {
                if (r < 0 || r >= rows || c < 0 || c >= cols || visited[r][c] || bubbles[r][c] !== color) return;
                
                visited[r][c] = true;
                matches.push({ row: r, col: c });
                for (let [nr, nc] of getHexNeighbors(r, c)) {
                    floodFill(nr, nc);
                }
            }
            
            floodFill(startRow, startCol);
            
            if (matches.length >= 3) {
                comboMultiplier += 0.5;
                clearInterval(comboTimer);
                comboTimer = setInterval(() => {
                    comboMultiplier = Math.max(1, comboMultiplier - 0.1);
                }, 3000);
                challengeIndicator.innerHTML = `<i class="fas fa-trophy"></i> Combo x${Math.ceil(comboMultiplier)}`;
                comboIndicator.classList.add('show');
                setTimeout(() => comboIndicator.classList.remove('show'), 1000);
                
                let popScore = matches.length * 10 * comboMultiplier;
                score += popScore;
                scoreElement.textContent = Math.floor(score);
                
                playMatchSound(matches.length);
                
                matches.forEach(({ row, col }) => {
                    bubbles[row][col] = null;
                    const bubbleEl = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (bubbleEl) {
                        createParticles(bubbleEl.getBoundingClientRect(), color);
                        bubbleEl.style.transform = 'scale(1.2)';
                        bubbleEl.style.opacity = '0';
                        setTimeout(() => bubbleEl.remove(), 300);
                    }
                });
                
                // Drop bubbles
                setTimeout(dropBubbles, 400); // Delay for animation
            }
        }

        // Handle bomb explosion
        function handleBomb(row, col) {
            playBombSound();
            const explodeArea = 5; // 5x5
            let popped = 0;
            for (let dr = -Math.floor(explodeArea / 2); dr <= Math.floor(explodeArea / 2); dr++) {
                for (let dc = -Math.floor(explodeArea / 2); dc <= Math.floor(explodeArea / 2); dc++) {
                    const nr = row + dr, nc = col + dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && bubbles[nr][nc]) {
                        bubbles[nr][nc] = null;
                        const bubbleEl = document.querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
                        if (bubbleEl) {
                            createParticles(bubbleEl.getBoundingClientRect(), 'bomb');
                            bubbleEl.style.transform = 'scale(1.5)';
                            bubbleEl.style.opacity = '0';
                            setTimeout(() => bubbleEl.remove(), 300);
                        }
                        popped++;
                    }
                }
            }
            score += popped * 50 * comboMultiplier;
            scoreElement.textContent = Math.floor(score);
            setTimeout(dropBubbles, 400);
        }

        // Drop floating bubbles per column (approximation for hex)
        function dropBubbles() {
            for (let col = 0; col < cols; col++) {
                let writeRow = rows - 1;
                for (let readRow = rows - 1; readRow >= 0; readRow--) {
                    if (bubbles[readRow][col] !== null) {
                        if (writeRow !== readRow) {
                            bubbles[writeRow][col] = bubbles[readRow][col];
                            const oldEl = document.querySelector(`[data-row="${readRow}"][data-col="${col}"]`);
                            if (oldEl) oldEl.remove();
                            const newEl = createBubbleElement(writeRow, col, bubbles[writeRow][col]);
                            // Animate drop
                            const offsetX = writeRow % 2 === 1 ? hexOffset : 0;
                            const dy = (readRow - writeRow) * (bubbleSize + 1);
                            newEl.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                            newEl.style.transform = `translateY(${dy}px) translateX(${offsetX}px) scale(0.8)`;
                            setTimeout(() => {
                                newEl.style.transform = `translateX(${offsetX}px)`;
                            }, 600);
                        }
                        writeRow--;
                    }
                }
                while (writeRow >= 0) {
                    bubbles[writeRow][col] = null;
                    writeRow--;
                }
            }
        }

        // Create shooting bubble
        function createShootingBubble(color) {
            const bubble = document.createElement('div');
            bubble.className = `bubble ${color} shooting-bubble`;
            bubble.style.position = 'absolute';
            bubble.style.zIndex = '10';
            bubble.style.transform = 'translate(-50%, -50%)'; // Center on pos
            bubble.innerHTML = color === 'bomb' ? 'ðŸ’£' : '<i class="fas fa-circle"></i>';
            gameContainer.appendChild(bubble);
            return bubble;
        }

        // Enhanced particle explosion
        function createParticles(rect, color = 'random') {
            const particles = document.createElement('div');
            particles.className = 'particles';
            const contRect = gameContainer.getBoundingClientRect();
            particles.style.left = `${rect.left + rect.width / 2 - contRect.left}px`;
            particles.style.top = `${rect.top + rect.height / 2 - contRect.top}px`;
            gameContainer.appendChild(particles);
            
            const numParticles = 20 + Math.random() * 10; // 20-30 particles
            const colorMap = {
                red: 'hsl(0, 100%, 60%)',
                blue: 'hsl(210, 100%, 50%)',
                green: 'hsl(120, 100%, 50%)',
                yellow: 'hsl(60, 100%, 50%)',
                purple: 'hsl(270, 100%, 50%)',
                bomb: 'hsl(0, 100%, 40%)'
            };
            const baseColor = colorMap[color] || `hsl(${Math.random() * 360}, 100%, 70%)`;
            
            for (let i = 0; i < numParticles; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const angle = (i / numParticles) * Math.PI * 2;
                const speed = 20 + Math.random() * 40;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;
                const halfDx = dx / 2;
                const halfDy = dy / 2;
                particle.style.setProperty('--dx', `${dx}px`);
                particle.style.setProperty('--dy', `${dy}px`);
                particle.style.setProperty('--dx-half', `${halfDx}px`);
                particle.style.setProperty('--dy-half', `${halfDy}px`);
                particle.style.background = baseColor;
                particle.style.width = `${3 + Math.random() * 4}px`;
                particle.style.height = particle.style.width;
                particle.style.left = `-${parseFloat(particle.style.width) / 2}px`;
                particle.style.top = `-${parseFloat(particle.style.height) / 2}px`;
                particles.appendChild(particle);
            }
            
            setTimeout(() => particles.remove(), 800);
        }

        // Rotate cannon for buttons - Set target for smooth physics
        function rotateCannon(direction) {
            if (!gameActive || gamePaused) return;
            const delta = direction === 'left' ? -10 : 10; // Smaller steps for smoother feel
            cannonTargetAngle += delta;
            cannonTargetAngle = Math.max(0, Math.min(180, cannonTargetAngle));
        }

        // Event listeners
        leftBtn.addEventListener('click', () => rotateCannon('left'));
        rightBtn.addEventListener('click', () => rotateCannon('right'));
        shootBtn.addEventListener('click', () => shootBubble());
        
        pauseBtn.addEventListener('click', togglePause);
        infoBtn.addEventListener('click', () => instructionsModal.classList.add('active'));
        closeInstructions.addEventListener('click', () => instructionsModal.classList.remove('active'));
        
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', initGame);
        
        // Enhanced touch/mouse aiming
        let isDragging = false;
        
        function handleStart(e) {
            e.preventDefault();
            isDragging = true;
            const clientX = e.clientX || e.touches[0].clientX;
            updateAim(clientX);
        }
        
        function handleMove(e) {
            if (!isDragging || !gameActive || gamePaused) return;
            e.preventDefault();
            const clientX = e.clientX || e.touches[0].clientX;
            updateAim(clientX);
        }
        
        function handleEnd(e) {
            if (!isDragging) return;
            isDragging = false;
            const clientX = e.clientX || e.changedTouches[0].clientX;
            // If drag distance small, treat as tap to shoot
            shootBubble(clientX);
        }
        
        gameContainer.addEventListener('mousedown', handleStart);
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);
        
        gameContainer.addEventListener('touchstart', handleStart, { passive: false });
        gameContainer.addEventListener('touchmove', handleMove, { passive: false });
        gameContainer.addEventListener('touchend', handleEnd, { passive: false });
        
        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (!gameActive || gamePaused) return;
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                rotateCannon('left');
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                rotateCannon('right');
            }
            if (e.key === ' ') {
                e.preventDefault();
                shootBubble();
            }
            if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                togglePause();
            }
        });
        
        // Resize handler for cannon pos
        window.addEventListener('resize', updateCannonPos);
        
        // Init
        initGame();
    </script>
</body>
</html>