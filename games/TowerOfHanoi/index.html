<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tower of Hanoi — Drag & Drop</title>
  <style>
    :root {
      --primary: #3498db;
      --primary-dark: #2980b9;
      --secondary: #6a11cb;
      --secondary-dark: #4a00a8;
      --card-bg: #ffffff;
      --bg-gradient: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      --text-dark: #2c3e50;
      --text-light: #ffffff;
      --success: #2ecc71;
      --error: #e74c3c;
      --warning: #f39c12;
    }
    * { box-sizing: border-box; }
    html, body { 
      height: 100%; 
      margin: 0; 
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
      background: var(--bg-gradient);
      background-attachment: fixed;
    }
    .app { 
      min-height: 100vh;
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      padding: 16px;
      padding-bottom: 20px;
    }
    .header { 
      width: 100%; 
      max-width: 960px; 
      display: flex; 
      gap: 12px; 
      align-items: center; 
      justify-content: space-between; 
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    h1 { 
      font-size: 24px; 
      margin: 0; 
      color: var(--text-light);
      text-shadow: 0 2px 4px rgba(0,0,0,0.2);
      font-weight: 700;
    }
    .controls { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .controls select, .controls button { 
      padding: 10px 14px; 
      border-radius: 10px; 
      border: none; 
      cursor: pointer; 
      font-weight: 600; 
      font-size: 14px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.16);
      transition: all 0.2s ease;
    }
    .controls select { 
      background: var(--card-bg); 
      color: var(--text-dark);
    }
    .controls button { 
      color: var(--text-light);
    }
    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.2);
    }
    .controls button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .controls button#reset { 
      background: var(--secondary);
    }
    .controls button#reset:hover { 
      background: var(--secondary-dark);
    }
    .controls button#hint { 
      background: var(--warning);
    }
    .controls button#hint:hover { 
      background: #e67e22;
    }
    .controls button#auto { 
      background: var(--primary);
    }
    .controls button#auto:hover { 
      background: var(--primary-dark);
    }
    .board-wrap { 
      width: 100%; 
      max-width: 960px; 
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--card-bg); 
      padding: 20px; 
      border-radius: 16px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      margin-bottom: 10px;
    }
    .board { 
      flex: 1;
      display: flex; 
      justify-content: space-between; 
      align-items: flex-end; 
      padding: 12px 8px; 
      gap: 8px; 
      position: relative;
      min-height: 220px;
    }
    .peg { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      position: relative;
      height: 100%;
      max-width: 30%;
    }
    .peg-base { 
      width: 80%; 
      height: 12px; 
      background: #7f8c8d; 
      border-radius: 6px; 
      margin-top: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .peg-stem { 
      position: absolute; 
      bottom: 20px; 
      width: 14px; 
      height: calc(100% - 40px); 
      background: linear-gradient(to right, #95a5a6, #7f8c8d);
      border-radius: 7px; 
      box-shadow: 0 3px 6px rgba(0,0,0,0.1);
      z-index: 1;
    }
    .stack { 
      position: absolute; 
      bottom: 32px; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 4px; 
      width: 100%; 
      height: calc(100% - 40px);
      pointer-events: none; 
      z-index: 2;
      justify-content: flex-end;
    }
    .disc { 
      height: 24px; 
      border-radius: 12px; 
      box-shadow: 0 3px 6px rgba(0,0,0,0.16), inset 0 -2px 4px rgba(0,0,0,0.1); 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: 700; 
      color: var(--text-dark); 
      pointer-events: auto; 
      cursor: grab; 
      transition: transform 0.2s ease;
      z-index: 3;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .disc:active { 
      cursor: grabbing;
      transform: scale(1.05) rotate(2deg);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2), inset 0 -2px 4px rgba(0,0,0,0.1);
    }
    .floating { 
      position: fixed; 
      z-index: 9999; 
      pointer-events: none; 
      transform: translate(-50%,-50%);
      opacity: 0.9;
    }
    .meta { 
      display: flex; 
      gap: 12px; 
      align-items: center; 
      margin-top: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .meta .info { 
      background: #f8f9fa; 
      padding: 8px 14px; 
      border-radius: 10px; 
      box-shadow: 0 2px 5px rgba(0,0,0,0.08); 
      color: var(--text-dark);
      font-size: 14px;
      font-weight: 600;
    }
    .message { 
      margin-top: 16px; 
      padding: 12px; 
      border-radius: 10px; 
      background: #ecf0f1; 
      color: var(--secondary-dark); 
      font-weight: 600; 
      text-align: center;
      box-shadow: 0 3px 6px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
    }
    .message.success {
      background: var(--success);
      color: white;
    }
    .message.error {
      background: var(--error);
      color: white;
    }
    .loader-overlay { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      background: rgba(0,0,0,0.6); 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      z-index: 10000; 
    }
    .spinner { 
      border: 6px solid #f3f3f3; 
      border-top: 6px solid var(--primary); 
      border-radius: 50%; 
      width: 50px; 
      height: 50px; 
      animation: spin 1s linear infinite; 
    }
    @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
    
    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .app {
        padding: 12px;
        padding-bottom: 16px;
      }
      
      .header {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
        margin-bottom: 8px;
      }
      
      h1 {
        text-align: center;
        font-size: 22px;
      }
      
      .controls {
        justify-content: center;
      }
      
      .controls select, .controls button {
        padding: 8px 12px;
        font-size: 13px;
      }
      
      .board-wrap {
        padding: 16px;
        border-radius: 14px;
      }
      
      .board {
        padding: 8px 4px;
        min-height: 180px;
      }
      
      .peg-stem {
        width: 12px;
        bottom: 18px;
      }
      
      .stack {
        bottom: 30px;
        gap: 3px;
      }
      
      .disc {
        height: 20px;
        font-size: 11px;
        border-radius: 10px;
      }
      
      .meta {
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
      }
      
      .meta .info {
        text-align: center;
        padding: 6px 10px;
      }
    }
    
    @media (max-width: 480px) {
      .controls {
        flex-wrap: nowrap;
        overflow-x: auto;
        padding-bottom: 4px;
        justify-content: flex-start;
      }
      
      .controls::-webkit-scrollbar {
        height: 4px;
      }
      
      .controls::-webkit-scrollbar-thumb {
        background: rgba(255,255,255,0.3);
        border-radius: 2px;
      }
      
      .board {
        min-height: 160px;
      }
      
      .peg-stem {
        width: 10px;
      }
      
      .disc {
        height: 18px;
        font-size: 10px;
      }
    }
    
    /* Animation for disc movement */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .pulse {
      animation: pulse 0.5s ease;
    }
    
    /* Highlight for valid move target */
    .peg.valid-target .peg-stem {
      background: linear-gradient(to right, #2ecc71, #27ae60);
      box-shadow: 0 0 0 3px rgba(46, 204, 113, 0.4);
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <h1>Tower of Hanoi</h1>
      <div class="controls">
        <label for="n">Discs:</label>
        <select id="n">
          <option>3</option>
          <option>4</option>
          <option selected>5</option>
          <option>6</option>
          <option>7</option>
        </select>
        <button id="reset">Reset</button>
        <button id="hint">Hint</button>
        <button id="auto">Auto-solve</button>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board" id="board">
        <div class="peg" data-peg="0">
          <div class="peg-stem"></div>
          <div class="stack" data-stack="0"></div>
          <div class="peg-base"></div>
        </div>
        <div class="peg" data-peg="1">
          <div class="peg-stem"></div>
          <div class="stack" data-stack="1"></div>
          <div class="peg-base"></div>
        </div>
        <div class="peg" data-peg="2">
          <div class="peg-stem"></div>
          <div class="stack" data-stack="2"></div>
          <div class="peg-base"></div>
        </div>
      </div>
      <div class="meta">
        <div class="info">Moves: <span id="moves">0</span></div>
        <div class="info">Optimal: <span id="optimal">0</span></div>
        <div class="info">Drag only the top disc</div>
      </div>
      <div id="message" class="message" style="display:none"></div>
    </div>
  </div>
  <script>
    // Improved JS with better feedback and mobile support
    let pegs = [[], [], []];
    let n = 5;
    let moves = 0;
    let optimal = 0;
    let dragState = null;
    let autoMoves = [];
    let autoTimer = null;

    const nSelect = document.getElementById('n');
    const movesEl = document.getElementById('moves');
    const optEl = document.getElementById('optimal');
    const msgEl = document.getElementById('message');
    const hintBtn = document.getElementById('hint');
    const resetBtn = document.getElementById('reset');
    const autoBtn = document.getElementById('auto');
    const boardEl = document.getElementById('board');

    function init() {
      n = parseInt(nSelect.value, 10);
      pegs = [[], [], []];
      for (let i = n; i >= 1; i--) pegs[0].push(i);
      moves = 0;
      optimal = Math.pow(2, n) - 1;
      movesEl.textContent = moves;
      optEl.textContent = optimal;
      msgEl.style.display = 'none';
      msgEl.className = 'message';
      autoMoves = [];
      stopAuto();
      render();
    }

    function render() {
      for (let p = 0; p < 3; p++) {
        const stack = document.querySelector(`.stack[data-stack="${p}"]`);
        stack.innerHTML = '';
        const arr = pegs[p];
        for (let i = 0; i < arr.length; i++) {
          const size = arr[i];
          const disc = document.createElement('div');
          disc.className = 'disc';
          disc.dataset.size = size;
          disc.dataset.peg = p;
          disc.textContent = size;
          const pct = 30 + (size / n) * 60;
          disc.style.width = pct + '%';
          const hue = Math.round(200 - (size / n) * 140);
          disc.style.background = `linear-gradient(135deg, hsl(${hue}, 80%, 70%), hsl(${hue}, 70%, 55%))`;
          if (i === arr.length - 1) disc.setAttribute('data-top','1');
          stack.appendChild(disc);
        }
      }
      attachDiscHandlers();
    }

    function attachDiscHandlers() {
      document.querySelectorAll('.disc').forEach(d => { d.onpointerdown = null; });
      document.querySelectorAll('.disc').forEach(disc => { 
        if (!disc.hasAttribute('data-top')) return; 
        disc.style.touchAction = 'none'; 
        disc.onpointerdown = onPointerDown; 
      });
    }

    function onPointerDown(e) {
      e.preventDefault();
      const disc = e.currentTarget;
      const size = parseInt(disc.dataset.size, 10);
      const fromPeg = parseInt(disc.dataset.peg, 10);
      dragState = { discEl: disc, size, fromPeg, origParent: disc.parentElement, origNextSibling: disc.nextElementSibling };
      
      // Create floating clone
      const clone = disc.cloneNode(true);
      clone.classList.add('floating');
      clone.style.width = disc.offsetWidth + 'px';
      clone.style.left = e.clientX + 'px';
      clone.style.top = e.clientY + 'px';
      document.body.appendChild(clone);
      dragState.clone = clone;
      disc.style.visibility = 'hidden';
      
      // Add highlight to valid target pegs
      highlightValidTargets(size);
      
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
    }

    function highlightValidTargets(size) {
      document.querySelectorAll('.peg').forEach(pegEl => {
        const pegNum = parseInt(pegEl.dataset.peg, 10);
        const peg = pegs[pegNum];
        const topDisc = peg.length ? peg[peg.length-1] : Infinity;
        
        if (topDisc > size) {
          pegEl.classList.add('valid-target');
        }
      });
    }

    function removeHighlights() {
      document.querySelectorAll('.peg').forEach(pegEl => {
        pegEl.classList.remove('valid-target');
      });
    }

    function onPointerMove(e) { 
      if (!dragState) return; 
      dragState.clone.style.left = e.clientX + 'px'; 
      dragState.clone.style.top = e.clientY + 'px'; 
    }

    function onPointerUp(e) {
      if (!dragState) return;
      const x = e.clientX; 
      const y = e.clientY;
      let targetPeg = null;
      
      document.querySelectorAll('.peg').forEach(pe => { 
        const r = pe.getBoundingClientRect(); 
        if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) {
          targetPeg = parseInt(pe.dataset.peg, 10); 
        }
      });
      
      const {size, fromPeg, discEl, clone} = dragState;
      clone.remove(); 
      discEl.style.visibility = '';
      removeHighlights();
      
      if (targetPeg === null || targetPeg === fromPeg) { 
        cleanupDrag(); 
        return; 
      }
      
      const dest = pegs[targetPeg];
      const topDest = dest.length ? dest[dest.length-1] : Infinity;
      
      if (topDest > size) { 
        const src = pegs[fromPeg]; 
        const popped = src.pop(); 
        if (popped !== size) { 
          cleanupDrag(); 
          return; 
        } 
        dest.push(size); 
        moves++; 
        movesEl.textContent = moves; 
        render(); 
        checkWin(); 
      } else { 
        flashMessage('Cannot place a larger disc on a smaller one', 1200, 'error');
      }
      
      cleanupDrag();
    }

    function cleanupDrag() { 
      removeHighlights();
      window.removeEventListener('pointermove', onPointerMove); 
      window.removeEventListener('pointerup', onPointerUp); 
      dragState = null; 
    }

    function flashMessage(text, ms=1200, type='') { 
      msgEl.textContent = text; 
      msgEl.className = type ? `message ${type}` : 'message';
      msgEl.style.display = 'block'; 
      clearTimeout(msgEl._t); 
      msgEl._t = setTimeout(()=>{
        msgEl.style.display='none';
        msgEl.className = 'message';
      }, ms); 
    }

    function checkWin() { 
      if (pegs[2].length === n) { 
        const efficiency = moves === optimal ? "Perfect!" : moves < optimal * 1.2 ? "Good job!" : "Keep practicing!";
        flashMessage(`${efficiency} Solved in ${moves} moves! Optimal: ${optimal}`, 6000, 'success'); 
        stopAuto(); 
      } 
    }

    function buildAutoMoves() { 
      autoMoves = []; 
      function h(k, a, b, c) { 
        if (k === 0) return; 
        h(k-1, a, c, b); 
        autoMoves.push([a, b]); 
        h(k-1, c, b, a);
      } 
      
      let startPeg = 0; // Always start from first peg
      let aux = 1; // Auxiliary peg
      let target = 2; // Target peg
      
      h(n, startPeg, target, aux); 
    }

    function doAutoStep() { 
      if (!autoMoves.length) { 
        stopAuto(); 
        return; 
      } 
      const [from, to] = autoMoves.shift(); 
      const src = pegs[from]; 
      if (!src.length) return; 
      const size = src[src.length-1]; 
      const dest = pegs[to]; 
      const topDest = dest.length ? dest[dest.length-1] : Infinity; 
      if (topDest > size) { 
        src.pop(); 
        dest.push(size); 
        moves++; 
        movesEl.textContent = moves; 
        render(); 
        checkWin(); 
      } 
    }

    function startAuto(interval=500) { 
      if (autoTimer) return; 
      buildAutoMoves(); 
      autoBtn.textContent = 'Stop';
      autoBtn.style.background = var(--error);
      
      // Show initial message
      flashMessage('Auto-solving... Click Stop to cancel', 2000);
      
      autoTimer = setInterval(() => { 
        if (!autoMoves.length) {
          stopAuto(); 
        } else {
          doAutoStep(); 
        }
      }, interval); 
    }

    function stopAuto() { 
      if (autoTimer) { 
        clearInterval(autoTimer); 
        autoTimer = null; 
        autoBtn.textContent = 'Auto-solve'; 
        autoBtn.style.background = '';
      } 
    }

    hintBtn.addEventListener('click', () => { 
      buildAutoMoves(); 
      if (autoMoves.length) { 
        const [from, to] = autoMoves[0]; // Just peek at the next move
        flashMessage(`Next move: Peg ${from+1} → Peg ${to+1}`, 2000);
        
        // Visual hint - pulse the disc to move
        const sourcePeg = pegs[from];
        if (sourcePeg.length) {
          const discEl = document.querySelector(`.stack[data-stack="${from}"] .disc[data-top="1"]`);
          if (discEl) {
            discEl.classList.add('pulse');
            setTimeout(() => discEl.classList.remove('pulse'), 1000);
          }
        }
      } else {
        flashMessage('No hint available', 1000, 'error');
      } 
    });

    resetBtn.addEventListener('click', () => { 
      // Add a quick animation effect on reset
      boardEl.style.opacity = '0.7';
      setTimeout(() => {
        init();
        boardEl.style.opacity = '1';
      }, 300);
    });

    autoBtn.addEventListener('click', () => { 
      if (autoTimer) {
        stopAuto(); 
      } else {
        startAuto(400); 
      } 
    });

    nSelect.addEventListener('change', () => { 
      init(); 
    });

    window.addEventListener('keydown', (e) => { 
      if (e.key === 'r' || e.key === 'R') init(); 
      if (e.key === 'a' || e.key === 'A') {
        if (autoTimer) stopAuto(); 
        else startAuto(400);
      } 
      if (e.key === 'h' || e.key === 'H') hintBtn.click(); 
    });

    // Improved mobile touch handling
    document.addEventListener('touchstart', function(e) {
      // Prevent zooming/scrolling when interacting with game elements
      if (e.target.closest('.disc') || e.target.closest('button')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Initialize the game
    init();
    
    // Prevent text selection during drag operations
    window.addEventListener('selectstart', e => { 
      if (dragState) e.preventDefault(); 
    });
  </script>
</body>
</html>