<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fixed Doodle Jump</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #98FB98 100%);
            font-family: 'Comic Sans MS', cursive;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            border: 3px solid #333;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 50%, #87CEEB 100%);
            max-width: 100vw;
            max-height: 100vh;
            touch-action: none;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 10;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #score {
            font-size: 24px;
            font-weight: bold;
        }
        
        #powerUpIndicator {
            position: absolute;
            top: 60px;
            left: 20px;
            right: 20px;
            text-align: center;
            color: #FFD700;
            font-size: 16px;
            font-weight: bold;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
        }
        
        #restartBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            font-family: inherit;
        }
        
        #restartBtn:hover {
            background: #45a049;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            text-align: center;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        @media (max-width: 768px) {
            #ui {
                font-size: 16px;
            }
            #score {
                font-size: 20px;
            }
            #instructions {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="400" height="700"></canvas>
        
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="height">Height: 0m</div>
            <div id="combo" style="color: #FFD700;"></div>
        </div>
        
        <div id="powerUpIndicator"></div>
        
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <p id="finalScore">Final Score: 0</p>
            <p id="finalHeight">Max Height: 0m</p>
            <p id="bestScore">Best Score: 0</p>
            <button id="restartBtn">Play Again</button>
        </div>
        
        <div id="instructions">
            Arrow Keys or Tilt to move â€¢ Player only jumps when landing on platforms from above
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            CANVAS_WIDTH: 400,
            CANVAS_HEIGHT: 700,
            GRAVITY: 0.4,
            JUMP_VELOCITY: -15,
            PLAYER_SPEED: 5,
            PLATFORM_GAP: 120,
            MAX_PLATFORMS: 20,
            BULLET_SPEED: 8,
            MONSTER_SPEED: 1,
            POWER_UP_DURATION: 300,
            PARTICLE_COUNT: 6
        };

        // Game Variables
        let canvas, ctx, game;
        let animationId;
        let lastTime = 0;
        let deviceOrientation = { beta: 0, gamma: 0 };
        let touchStartX = 0;
        let isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Example Player SVG as PNG base64
        const doodleBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAACMw0OaAAAAAXNSR0IArs4c6QAAAyJJREFUaEPtmsENAiEMBd/9r1yl3IhVlEPxpPovDA5BaWL3HgE00yzgpyH1WkH1WkX1UggDy6HB78e7psuXK9hVmk8m8j+DWzqgpZTNvtwAQLN2bhfVosk+JH4dAbAAXfBa7fRYdlk+4AgiwMIC5w/hvPqKDxm8gQAdb1ByX9h6dvgf8AOBiArwRQATMN9KFSBywD2AGAYQpTDOgBcwSShP+B0UFw7M1uTf4Nb9v1cVJGx+pV7qbvVq0D8IQXQEA1CFGoAJsGm88MIYBWfWCBADywEMFqvFRwCYQClMmgBoZk6mCoQZvsBsMY1vmfOBCgC0gzFSSQCSy9XFlYAaoGVhKbePrGZTkrjOUCKoUC9JTAFrAu4Er0tWlGWAUMuMCIgkFhZBZYiXKSqrD5oJQJnABLoErguJGUgqCytCZICQrSQFyK+p1kRwFQCTpKzIdd7s1w4Aa4BRySRw9E+qDCNPYH2M6HoQpUaM+9Zs5M3wZ0TdSmN6ZTqwBGEXnQyGHf5wYAAAAASUVORK5CYII=';
        // Example Platform SVG as PNG base64
        const platformBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABPUlEQVR4Xu3XvQmDMAwA0b7Q/2Lby00t8Zc3CTQpSxD/S8jWhzIuhzYTWU6wBs9XAJaw5ILXShiajRBIX5YiH5DDtXsApD8A5txmfhvc01TMzKzq8AG3T/Iq3VE8ENWcACgjoSmKT5iWqUGgArHqR3zGA5VKB/4shrQcR2M0TJacwoJAgN7txE3tRW9swI7A9S1F2DkQiXFDKHqB2diHMPMj3Aaxt4CN5rgNw9yA+C4KnozMCe517ocmyZtAvdH7TWt8nssCvgeHG8+J+91Yb0Kkln7gl8d/G4t6uI1AScsRpHXAAAAAElFTkSuQmCC';

        

        // Game State
        const gameState = {
            isPlaying: false,
            score: 0,
            height: 0,
            bestScore: localStorage.getItem('doodleJumpBest') || 0,
            combo: 0,
            camera: { y: 0 },
            particles: [],
            bullets: [],
            powerUps: [],
            monsters: []
        };

        // Platform Types
        const PLATFORM_TYPES = {
            NORMAL: { color: '#4CAF50', width: 70, height: 15, isBreakable: false, isMoving: false },
            SPRING: { color: '#FF9800', width: 50, height: 20, isBreakable: false, isMoving: false, jumpBoost: 2 },
            MOVING: { color: '#2196F3', width: 70, height: 15, isBreakable: false, isMoving: true, speed: 1.5 },
            BREAKABLE: { color: '#8B4513', width: 70, height: 15, isBreakable: true, isMoving: false },
            CLOUD: { color: '#E0E0E0', width: 80, height: 20, isBreakable: false, isMoving: false, isCloud: true }
        };

        // Power-up Types
        const POWER_UP_TYPES = {
            JETPACK: { color: '#FF4444', duration: 180, effect: 'jetpack' },
            PROPELLER: { color: '#44FF44', duration: 240, effect: 'propeller' },
            SHIELD: { color: '#4444FF', duration: 300, effect: 'shield' },
            SPRING_SHOES: { color: '#FF44FF', duration: 360, effect: 'springShoes' }
        };

        // Enhanced Player Class with Fixed Movement
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 60;
                this.velocityX = 0;
                this.velocityY = 0;
                this.isOnGround = false;
                this.previousY = y;
                this.direction = 1;
                this.activePowerUp = null;
                this.powerUpTimer = 0;
                this.invulnerable = false;
                this.invulnerabilityTimer = 0;
                this.animationFrame = 0;
                this.jumpCount = 0;
            }

            update() {
                // Store previous position for collision detection
                this.previousY = this.y;
                
                // Handle power-ups
                if (this.activePowerUp) {
                    this.powerUpTimer--;
                    if (this.powerUpTimer <= 0) {
                        this.activePowerUp = null;
                        document.getElementById('powerUpIndicator').textContent = '';
                    } else {
                        this.applyPowerUpEffect();
                    }
                }

                // Handle invulnerability
                if (this.invulnerable) {
                    this.invulnerabilityTimer--;
                    if (this.invulnerabilityTimer <= 0) {
                        this.invulnerable = false;
                    }
                }

                // Apply gravity only if not using jetpack
                if (!this.activePowerUp || this.activePowerUp !== 'jetpack') {
                    this.velocityY += CONFIG.GRAVITY;
                }

                // Apply horizontal movement with air resistance
                this.velocityX *= 0.92;
                this.x += this.velocityX;

                // Screen wrapping
                if (this.x < -this.width/2) {
                    this.x = CONFIG.CANVAS_WIDTH - this.width/2;
                } else if (this.x > CONFIG.CANVAS_WIDTH - this.width/2) {
                    this.x = -this.width/2;
                }

                // Apply vertical movement
                this.y += this.velocityY;

                // Reset ground status (will be set by collision detection)
                this.isOnGround = false;

                // Update animation
                this.animationFrame = (this.animationFrame + 0.2) % 4;

                // Update camera only when moving upward and above midpoint
                if (this.velocityY < 0 && this.y < gameState.camera.y + CONFIG.CANVAS_HEIGHT * 0.4) {
                    gameState.camera.y = this.y - CONFIG.CANVAS_HEIGHT * 0.4;
                }

                // Update height score
                let currentHeight = Math.max(0, Math.floor((game.startY - this.y) / 10));
                if (currentHeight > gameState.height) {
                    gameState.height = currentHeight;
                    gameState.score += (currentHeight - gameState.height + 1) * (gameState.combo + 1);
                }
            }

            applyPowerUpEffect() {
                switch (this.activePowerUp) {
                    case 'jetpack':
                        this.velocityY = Math.min(this.velocityY, -8);
                        // Add jetpack particles
                        for (let i = 0; i < 3; i++) {
                            game.addParticle(this.x + this.width/2 + Math.random() * 20 - 10, 
                                           this.y + this.height, '#FF4444', 2);
                        }
                        break;
                    case 'propeller':
                        this.velocityY = Math.min(this.velocityY, -6);
                        break;
                }
            }

            // FIXED: Only jump when landing on platform from above
            jump(boostMultiplier = 1) {
                let jumpVel = CONFIG.JUMP_VELOCITY * boostMultiplier;
                
                if (this.activePowerUp === 'springShoes') {
                    jumpVel *= 1.5;
                }
                
                this.velocityY = jumpVel;
                this.isOnGround = true;
                this.jumpCount++;
                
                // Add jump particles
                for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                    game.addParticle(this.x + this.width/2, this.y + this.height, '#FFFFFF', 1.5);
                }

                // Combo system
                gameState.combo = Math.min(gameState.combo + 1, 10);
            }

            setPowerUp(type) {
                this.activePowerUp = type;
                this.powerUpTimer = POWER_UP_TYPES[type.toUpperCase()].duration;
                document.getElementById('powerUpIndicator').textContent = 
                    `Power-up: ${type.toUpperCase()} (${Math.floor(this.powerUpTimer/60)}s)`;
            }

            takeDamage() {
                if (!this.invulnerable && (!this.activePowerUp || this.activePowerUp !== 'shield')) {
                    game.gameOver();
                }
            }

            draw() {
                ctx.save();
                
                // Draw invulnerability effect
                if (this.invulnerable && Math.floor(this.invulnerabilityTimer / 10) % 2) {
                    ctx.globalAlpha = 0.5;
                }

                // Draw shield effect
                if (this.activePowerUp === 'shield') {
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2 + 10, 0, Math.PI * 2);
                    ctx.strokeStyle = '#4444FF';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Draw player body
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Draw face
                ctx.fillStyle = '#FFFFFF';
                let eyeY = this.y + 15;
                let eyeOffset = this.direction > 0 ? 10 : -10;
                
                // Eyes
                ctx.fillRect(this.x + 15 + eyeOffset, eyeY, 8, 8);
                ctx.fillRect(this.x + 35 + eyeOffset, eyeY, 8, 8);
                
                // Pupils
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.x + 17 + eyeOffset, eyeY + 2, 4, 4);
                ctx.fillRect(this.x + 37 + eyeOffset, eyeY + 2, 4, 4);

                // Mouth
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + 35, 8, 0, Math.PI);
                ctx.fillStyle = '#000000';
                ctx.fill();

                // Draw power-up effects
                if (this.activePowerUp === 'propeller') {
                    this.drawPropeller();
                } else if (this.activePowerUp === 'jetpack') {
                    this.drawJetpack();
                } else if (this.activePowerUp === 'springShoes') {
                    this.drawSpringShoes();
                }

                ctx.restore();
            }

            drawPropeller() {
                ctx.fillStyle = '#44FF44';
                ctx.fillRect(this.x + this.width/2 - 25, this.y - 10, 50, 5);
                ctx.fillRect(this.x + this.width/2 - 2, this.y - 15, 4, 10);
            }

            drawJetpack() {
                ctx.fillStyle = '#FF4444';
                ctx.fillRect(this.x + 5, this.y + 10, 15, 30);
                ctx.fillRect(this.x + this.width - 20, this.y + 10, 15, 30);
            }

            drawSpringShoes() {
                ctx.fillStyle = '#FF44FF';
                ctx.fillRect(this.x + 5, this.y + this.height - 10, 20, 10);
                ctx.fillRect(this.x + this.width - 25, this.y + this.height - 10, 20, 10);
            }
        }

        // Enhanced Platform Class
        class Platform {
            constructor(x, y, type = 'NORMAL') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.properties = { ...PLATFORM_TYPES[type] };
                this.width = this.properties.width;
                this.height = this.properties.height;
                this.moveDirection = Math.random() > 0.5 ? 1 : -1;
                this.isBroken = false;
                this.breakTimer = 0;
                this.bounceAnimation = 0;
            }

            update() {
                if (this.properties.isMoving && !this.isBroken) {
                    this.x += this.properties.speed * this.moveDirection;
                    if (this.x <= 0 || this.x >= CONFIG.CANVAS_WIDTH - this.width) {
                        this.moveDirection *= -1;
                    }
                }

                if (this.isBroken) {
                    this.breakTimer++;
                    if (this.breakTimer > 30) {
                        return false;
                    }
                }

                if (this.bounceAnimation > 0) {
                    this.bounceAnimation--;
                }

                return true;
            }

            onJump() {
                if (this.properties.isBreakable) {
                    this.isBroken = true;
                    // Add break particles
                    for (let i = 0; i < 8; i++) {
                        game.addParticle(this.x + this.width/2, this.y, this.properties.color, 1);
                    }
                } else {
                    this.bounceAnimation = 15;
                }
            }

            draw() {
                if (this.isBroken) {
                    ctx.save();
                    ctx.globalAlpha = 1 - (this.breakTimer / 30);
                }

                let yOffset = this.bounceAnimation > 0 ? Math.sin(this.bounceAnimation * 0.5) * 3 : 0;
                
                ctx.fillStyle = this.properties.color;
                
                if (this.type === 'SPRING') {
                    ctx.fillRect(this.x, this.y + yOffset, this.width, this.height);
                    ctx.fillStyle = '#FF5722';
                    ctx.fillRect(this.x + this.width/2 - 5, this.y + yOffset - 5, 10, 10);
                } else if (this.type === 'CLOUD') {
                    ctx.beginPath();
                    ctx.arc(this.x + 20, this.y + 10 + yOffset, 15, 0, Math.PI * 2);
                    ctx.arc(this.x + 40, this.y + 10 + yOffset, 18, 0, Math.PI * 2);
                    ctx.arc(this.x + 60, this.y + 10 + yOffset, 15, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(this.x, this.y + yOffset, this.width, this.height);
                    
                    if (this.properties.isMoving) {
                        ctx.fillStyle = '#1976D2';
                        ctx.fillRect(this.x + 5, this.y + yOffset + 3, this.width - 10, 3);
                    }
                    
                    if (this.properties.isBreakable) {
                        ctx.fillStyle = '#654321';
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(this.x + i * 20 + 5, this.y + yOffset + 2, 10, 2);
                        }
                    }
                }

                if (this.isBroken) {
                    ctx.restore();
                }
            }
        }

        // Particle System
        class Particle {
            constructor(x, y, color, life = 1) {
                this.x = x + Math.random() * 20 - 10;
                this.y = y;
                this.velocityX = Math.random() * 6 - 3;
                this.velocityY = Math.random() * -8 - 2;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.velocityY += 0.2;
                this.life -= 0.02;
                return this.life > 0;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * (this.life / this.maxLife), 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Power-up Class
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 30;
                this.height = 30;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.collected = false;
            }

            update() {
                this.bobOffset += 0.1;
                return !this.collected;
            }

            draw() {
                let bobY = this.y + Math.sin(this.bobOffset) * 3;
                
                ctx.fillStyle = POWER_UP_TYPES[this.type].color;
                ctx.fillRect(this.x, bobY, this.width, this.height);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                let icon = '';
                switch (this.type) {
                    case 'JETPACK': icon = 'J'; break;
                    case 'PROPELLER': icon = 'P'; break;
                    case 'SHIELD': icon = 'S'; break;
                    case 'SPRING_SHOES': icon = 'B'; break;
                }
                ctx.fillText(icon, this.x + this.width/2, bobY + this.height/2 + 5);
            }
        }

        // Monster Class
        class Monster {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 40;
                this.height = 40;
                this.velocityX = (Math.random() - 0.5) * CONFIG.MONSTER_SPEED;
                this.destroyed = false;
                this.animationFrame = 0;
            }

            update() {
                this.x += this.velocityX;
                this.animationFrame += 0.1;
                
                if (this.x <= 0 || this.x >= CONFIG.CANVAS_WIDTH - this.width) {
                    this.velocityX *= -1;
                }

                return !this.destroyed;
            }

            takeDamage() {
                this.destroyed = true;
                gameState.score += 100 * (gameState.combo + 1);
                
                for (let i = 0; i < 6; i++) {
                    game.addParticle(this.x + this.width/2, this.y + this.height/2, '#FF4444', 1);
                }
            }

            draw() {
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.fillStyle = '#FF0000';
                let eyeBob = Math.sin(this.animationFrame) * 2;
                ctx.fillRect(this.x + 8, this.y + 8 + eyeBob, 8, 8);
                ctx.fillRect(this.x + 24, this.y + 8 + eyeBob, 8, 8);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.x + 12, this.y + 24, 4, 8);
                ctx.fillRect(this.x + 20, this.y + 24, 4, 8);
                ctx.fillRect(this.x + 28, this.y + 24, 4, 8);
            }
        }

        // Bullet Class
        class Bullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 6;
                this.height = 12;
                this.velocityY = -CONFIG.BULLET_SPEED;
                this.active = true;
            }

            update() {
                this.y += this.velocityY;
                
                if (this.y < gameState.camera.y - 100) {
                    this.active = false;
                }
                
                return this.active;
            }

            draw() {
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(this.x + 1, this.y + 1, this.width - 2, this.height - 2);
            }
        }

        // Main Game Class
        class Game {
            constructor() {
                this.player = new Player(CONFIG.CANVAS_WIDTH / 2 - 30, CONFIG.CANVAS_HEIGHT - 150);
                this.platforms = [];
                this.startY = this.player.y;
                this.difficultyLevel = 1;
                this.lastPlatformY = CONFIG.CANVAS_HEIGHT - 50;
                this.keys = {};
                this.shootCooldown = 0;
                
                this.generateInitialPlatforms();
                this.setupEventListeners();
            }

            generateInitialPlatforms() {
                // Starting platform
                this.platforms.push(new Platform(CONFIG.CANVAS_WIDTH / 2 - 35, CONFIG.CANVAS_HEIGHT - 50, 'NORMAL'));
                
                for (let i = 1; i < CONFIG.MAX_PLATFORMS; i++) {
                    this.generateRandomPlatform();
                }
            }

            generateRandomPlatform() {
                let x = Math.random() * (CONFIG.CANVAS_WIDTH - 100) + 50;
                this.lastPlatformY -= CONFIG.PLATFORM_GAP + Math.random() * 40 - 20;
                
                let type = 'NORMAL';
                let rand = Math.random();
                
                if (rand < 0.15) type = 'SPRING';
                else if (rand < 0.25) type = 'MOVING';
                else if (rand < 0.35) type = 'BREAKABLE';
                else if (rand < 0.45) type = 'CLOUD';
                
                let platform = new Platform(x, this.lastPlatformY, type);
                this.platforms.push(platform);
                
                if (Math.random() < 0.08) {
                    let powerUpTypes = Object.keys(POWER_UP_TYPES);
                    let randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    gameState.powerUps.push(new PowerUp(x + 20, this.lastPlatformY - 35, randomType));
                }
                
                if (Math.random() < 0.06 && this.difficultyLevel > 2) {
                    gameState.monsters.push(new Monster(x - 20, this.lastPlatformY - 45));
                }
            }

            addParticle(x, y, color, life) {
                gameState.particles.push(new Particle(x, y, color, life));
            }

            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === ' ' || e.key === 'Spacebar') {
                        this.shoot();
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // Touch controls
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchStartX = e.touches[0].clientX;
                    this.shoot();
                });

                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    let touch = e.touches[0];
                    let deltaX = touch.clientX - touchStartX;
                    
                    if (Math.abs(deltaX) > 20) {
                        this.player.velocityX += deltaX * 0.02;
                        this.player.direction = deltaX > 0 ? 1 : -1;
                        touchStartX = touch.clientX;
                    }
                });

                // Mouse controls
                canvas.addEventListener('click', () => {
                    this.shoot();
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (e.buttons === 1) {
                        let rect = canvas.getBoundingClientRect();
                        let mouseX = e.clientX - rect.left;
                        let canvasMouseX = mouseX * (CONFIG.CANVAS_WIDTH / rect.width);
                        
                        let deltaX = canvasMouseX - (this.player.x + this.player.width/2);
                        this.player.velocityX += deltaX * 0.01;
                        this.player.direction = deltaX > 0 ? 1 : -1;
                    }
                });

                // Device orientation
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        deviceOrientation.gamma = e.gamma || 0;
                        deviceOrientation.beta = e.beta || 0;
                    });
                }

                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });
            }

            shoot() {
                if (this.shootCooldown <= 0) {
                    gameState.bullets.push(new Bullet(
                        this.player.x + this.player.width/2 - 3,
                        this.player.y
                    ));
                    this.shootCooldown = 15;
                }
            }

            handleInput() {
                // Keyboard movement
                if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) {
                    this.player.velocityX -= 0.8;
                    this.player.direction = -1;
                }
                if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) {
                    this.player.velocityX += 0.8;
                    this.player.direction = 1;
                }

                // Mobile tilt controls
                if (isMobile && Math.abs(deviceOrientation.gamma) > 5) {
                    this.player.velocityX += deviceOrientation.gamma * 0.15;
                    this.player.direction = deviceOrientation.gamma > 0 ? 1 : -1;
                }

                // Limit player speed
                this.player.velocityX = Math.max(-CONFIG.PLAYER_SPEED, 
                    Math.min(CONFIG.PLAYER_SPEED, this.player.velocityX));
            }

            // FIXED: Proper collision detection that only triggers when falling onto platform
            checkCollisions() {
                // Platform collisions - ONLY when falling (velocityY > 0) and coming from above
                if (this.player.velocityY > 0) {
                    for (let platform of this.platforms) {
                        if (!platform.isBroken) {
                            // Check if player overlaps horizontally with platform
                            let playerRight = this.player.x + this.player.width;
                            let playerLeft = this.player.x;
                            let platformRight = platform.x + platform.width;
                            let platformLeft = platform.x;
                            
                            // Check if player bottom is touching platform top
                            let playerBottom = this.player.y + this.player.height;
                            let playerPrevBottom = this.player.previousY + this.player.height;
                            let platformTop = platform.y;
                            let platformBottom = platform.y + platform.height;
                            
                            // Horizontal overlap check
                            let horizontalOverlap = playerRight > platformLeft && 
                                                  playerLeft < platformRight;
                            
                            // Vertical collision check - player was above platform and is now touching/below
                            let verticalCollision = playerPrevBottom <= platformTop && 
                                                  playerBottom >= platformTop && 
                                                  playerBottom <= platformBottom + 10; // Small tolerance
                            
                            if (horizontalOverlap && verticalCollision) {
                                // Land on platform - position player on top
                                this.player.y = platform.y - this.player.height;
                                
                                // Apply jump based on platform type
                                let jumpBoost = platform.properties.jumpBoost || 1;
                                this.player.jump(jumpBoost);
                                platform.onJump();
                                gameState.score += 10 * (gameState.combo + 1);
                                break;
                            }
                        }
                    }
                }

                // Power-up collisions
                for (let powerUp of gameState.powerUps) {
                    if (!powerUp.collected &&
                        this.player.x < powerUp.x + powerUp.width &&
                        this.player.x + this.player.width > powerUp.x &&
                        this.player.y < powerUp.y + powerUp.height &&
                        this.player.y + this.player.height > powerUp.y) {
                        
                        powerUp.collected = true;
                        this.player.setPowerUp(powerUp.type);
                        gameState.score += 50 * (gameState.combo + 1);
                        
                        for (let i = 0; i < 8; i++) {
                            this.addParticle(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, 
                                           POWER_UP_TYPES[powerUp.type].color, 1.5);
                        }
                    }
                }

                // Monster collisions
                for (let monster of gameState.monsters) {
                    if (!monster.destroyed &&
                        this.player.x < monster.x + monster.width &&
                        this.player.x + this.player.width > monster.x &&
                        this.player.y < monster.y + monster.height &&
                        this.player.y + this.player.height > monster.y) {
                        
                        this.player.takeDamage();
                        break;
                    }
                }

                // Bullet-monster collisions
                for (let bullet of gameState.bullets) {
                    for (let monster of gameState.monsters) {
                        if (bullet.active && !monster.destroyed &&
                            bullet.x < monster.x + monster.width &&
                            bullet.x + bullet.width > monster.x &&
                            bullet.y < monster.y + monster.height &&
                            bullet.y + bullet.height > monster.y) {
                            
                            bullet.active = false;
                            monster.takeDamage();
                            break;
                        }
                    }
                }
            }

            update() {
                if (!gameState.isPlaying) return;

                this.handleInput();
                
                if (this.shootCooldown > 0) this.shootCooldown--;

                this.player.update();
                this.platforms = this.platforms.filter(platform => platform.update());
                gameState.bullets = gameState.bullets.filter(bullet => bullet.update());
                gameState.particles = gameState.particles.filter(particle => particle.update());
                gameState.powerUps = gameState.powerUps.filter(powerUp => powerUp.update());
                gameState.monsters = gameState.monsters.filter(monster => monster.update());

                this.checkCollisions();

                while (this.platforms.length < CONFIG.MAX_PLATFORMS) {
                    this.generateRandomPlatform();
                }

                this.platforms = this.platforms.filter(platform => 
                    platform.y < gameState.camera.y + CONFIG.CANVAS_HEIGHT + 200
                );

                gameState.powerUps = gameState.powerUps.filter(powerUp => 
                    powerUp.y > gameState.camera.y - 100
                );
                gameState.monsters = gameState.monsters.filter(monster => 
                    monster.y > gameState.camera.y - 100
                );

                this.difficultyLevel = Math.floor(gameState.height / 100) + 1;

                if (this.player.y > gameState.camera.y + CONFIG.CANVAS_HEIGHT + 100) {
                    this.gameOver();
                }

                if (gameState.combo > 0 && Math.random() < 0.01) {
                    gameState.combo = Math.max(0, gameState.combo - 1);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(0, -gameState.camera.y);
                
                // Background
                let bgGradient = ctx.createLinearGradient(0, gameState.camera.y, 0, gameState.camera.y + CONFIG.CANVAS_HEIGHT);
                if (gameState.height < 100) {
                    bgGradient.addColorStop(0, '#1e3c72');
                    bgGradient.addColorStop(0.5, '#2a5298');
                    bgGradient.addColorStop(1, '#87CEEB');
                } else if (gameState.height < 300) {
                    bgGradient.addColorStop(0, '#0f0f23');
                    bgGradient.addColorStop(0.5, '#1a1a3a');
                    bgGradient.addColorStop(1, '#2d2d5a');
                } else {
                    bgGradient.addColorStop(0, '#000000');
                    bgGradient.addColorStop(0.5, '#1a0033');
                    bgGradient.addColorStop(1, '#330066');
                }
                
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, gameState.camera.y, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

                // Stars in space
                if (gameState.height > 200) {
                    ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < 50; i++) {
                        let starX = (i * 137) % CONFIG.CANVAS_WIDTH;
                        let starY = gameState.camera.y + (i * 197) % CONFIG.CANVAS_HEIGHT;
                        ctx.fillRect(starX, starY, 2, 2);
                    }
                }

                // Draw all game objects
                for (let platform of this.platforms) {
                    platform.draw();
                }

                for (let powerUp of gameState.powerUps) {
                    powerUp.draw();
                }

                for (let monster of gameState.monsters) {
                    monster.draw();
                }

                for (let bullet of gameState.bullets) {
                    bullet.draw();
                }

                for (let particle of gameState.particles) {
                    particle.draw();
                }

                this.player.draw();

                ctx.restore();
                this.updateUI();
            }

            updateUI() {
                document.getElementById('score').textContent = `Score: ${gameState.score}`;
                document.getElementById('height').textContent = `Height: ${gameState.height}m`;
                
                if (gameState.combo > 0) {
                    document.getElementById('combo').textContent = `Combo: x${gameState.combo + 1}`;
                } else {
                    document.getElementById('combo').textContent = '';
                }
            }

            gameOver() {
                gameState.isPlaying = false;
                
                if (gameState.score > gameState.bestScore) {
                    gameState.bestScore = gameState.score;
                    localStorage.setItem('doodleJumpBest', gameState.bestScore);
                }

                document.getElementById('finalScore').textContent = `Final Score: ${gameState.score}`;
                document.getElementById('finalHeight').textContent = `Max Height: ${gameState.height}m`;
                document.getElementById('bestScore').textContent = `Best Score: ${gameState.bestScore}`;
                document.getElementById('gameOverScreen').style.display = 'block';
            }

            restart() {
                gameState.isPlaying = true;
                gameState.score = 0;
                gameState.height = 0;
                gameState.combo = 0;
                gameState.camera.y = 0;
                gameState.particles = [];
                gameState.bullets = [];
                gameState.powerUps = [];
                gameState.monsters = [];

                this.player = new Player(CONFIG.CANVAS_WIDTH / 2 - 30, CONFIG.CANVAS_HEIGHT - 150);
                this.startY = this.player.y;
                
                this.platforms = [];
                this.lastPlatformY = CONFIG.CANVAS_HEIGHT - 50;
                this.generateInitialPlatforms();
                
                this.difficultyLevel = 1;
                this.shootCooldown = 0;

                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('powerUpIndicator').textContent = '';
            }
        }

        // Game Loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (game && gameState.isPlaying) {
                game.update();
                game.draw();
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // Initialize Game
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                let containerWidth = window.innerWidth;
                let containerHeight = window.innerHeight;
                let aspectRatio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
                
                if (containerWidth / containerHeight > aspectRatio) {
                    canvas.style.height = containerHeight * 0.9 + 'px';
                    canvas.style.width = (containerHeight * 0.9 * aspectRatio) + 'px';
                } else {
                    canvas.style.width = containerWidth * 0.9 + 'px';
                    canvas.style.height = (containerWidth * 0.9 / aspectRatio) + 'px';
                }
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            game = new Game();
            gameState.isPlaying = true;
            
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('load', initGame);

        // Prevent mobile scrolling
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());
        document.addEventListener('gestureend', (e) => e.preventDefault());
    </script>
</body>
</html>