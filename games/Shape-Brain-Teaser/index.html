<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>ðŸ”¥ Matchstick Math - Smooth Drag & Drop</title>
<style>
:root {
  --primary: #3498db;
  --secondary: #6a11cb;
  --success: #2ecc71;
  --danger: #e74c3c;
  --warning: #f39c12;
  --dark: #2c3e50;
  --light: #ecf0f1;
  --matchstick-color: linear-gradient(45deg, #e67e22, #d35400);
  --matchstick-shadow: 0 4px 8px rgba(230, 126, 34, 0.3);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  -webkit-tap-highlight-color: transparent;
}

body {
  margin: 0;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  touch-action: none;
  overflow: hidden;
}

.game-container {
  width: 100%;
  max-width: 500px;
  background: white;
  border-radius: 24px;
  padding: 24px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
  position: relative;
  overflow: hidden;
  animation: containerAppear 0.5s ease-out;
}

@keyframes containerAppear {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.game-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.stats {
  display: flex;
  gap: 12px;
}

.stat {
  background: var(--light);
  padding: 8px 16px;
  border-radius: 50px;
  font-weight: 600;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: transform 0.2s;
}

.stat.coins {
  background: linear-gradient(45deg, #FFD700, #FFA500);
  color: #8B4513;
}

.stat.streak {
  background: linear-gradient(45deg, #FF6B6B, #FF8E53);
  color: white;
}

.stat:hover {
  transform: scale(1.05);
}

.puzzle-info {
  text-align: center;
  margin-bottom: 20px;
  color: var(--dark);
  font-weight: 500;
}

.equation-container {
  background: #f8f9fa;
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 24px;
  border: 2px solid #e0e0e0;
  min-height: 200px;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  transition: all 0.3s;
}

.equation-container.active {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.equation {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
  min-height: 120px;
}

.digit-container {
  position: relative;
  width: 70px;
  height: 110px;
  margin: 0 5px;
  background: #f9f9f9;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: all 0.3s;
  border: 2px solid transparent;
}

.digit-container.drag-over {
  border-color: var(--success);
  background: rgba(46, 204, 113, 0.05);
  transform: scale(1.02);
}

.digit {
  position: relative;
  width: 60px;
  height: 100px;
  transform-style: preserve-3d;
}

.stick {
  position: absolute;
  background: var(--matchstick-color);
  border-radius: 4px;
  cursor: grab;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: var(--matchstick-shadow);
  z-index: 2;
  transform-origin: center;
  touch-action: none;
  user-select: none;
}

.stick::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: calc(100% - 4px);
  height: calc(100% - 4px);
  background: linear-gradient(45deg, rgba(255,255,255,0.2), rgba(255,255,255,0));
  border-radius: 2px;
  transform: translate(-50%, -50%);
}

.stick:hover:not(.dragging):not(.inactive) {
  transform: scale(1.05);
  box-shadow: 0 6px 12px rgba(230, 126, 34, 0.4);
}

.stick.dragging {
  cursor: grabbing;
  transform: scale(1.1) rotate(var(--rotation, 0deg));
  box-shadow: 0 8px 20px rgba(230, 126, 34, 0.6);
  z-index: 1000;
  opacity: 0.95;
  transition: transform 0.1s cubic-bezier(0.2, 0, 0, 1);
}

.stick.horizontal {
  width: 46px;
  height: 8px;
  --rotation: 5deg;
}

.stick.vertical {
  width: 8px;
  height: 46px;
  --rotation: -5deg;
}

.stick.inactive {
  background: #ecf0f1;
  box-shadow: none;
  cursor: default;
  pointer-events: none;
}

.stick.inactive::before {
  opacity: 0.3;
}

.stick.ghost {
  opacity: 0.4;
  pointer-events: none;
  z-index: 1;
}

.operator {
  font-size: 36px;
  font-weight: bold;
  color: var(--dark);
  padding: 0 10px;
  min-width: 20px;
  transition: transform 0.3s;
}

.actions {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 24px;
}

.btn {
  padding: 16px;
  border: none;
  border-radius: 12px;
  color: white;
  font-weight: 600;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  min-height: 50px;
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.btn:active::before {
  width: 300px;
  height: 300px;
}

.btn:active {
  transform: scale(0.95);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

.btn:disabled::before {
  display: none;
}

.btn.hint {
  background: linear-gradient(45deg, var(--warning), #ff9f43);
}

.btn.solution {
  background: linear-gradient(45deg, #9b59b6, #8e44ad);
}

.btn.next {
  background: linear-gradient(45deg, var(--primary), #2980b9);
  grid-column: span 2;
}

.btn.reset {
  background: linear-gradient(45deg, var(--danger), #c0392b);
}

.btn.undo {
  background: linear-gradient(45deg, #95a5a6, #7f8c8d);
}

.feedback {
  text-align: center;
  padding: 12px;
  border-radius: 12px;
  margin: 12px 0;
  font-weight: 600;
  animation: slideIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  transform-origin: top center;
}

.feedback.success {
  background: rgba(46, 204, 113, 0.1);
  color: var(--success);
  border: 2px solid rgba(46, 204, 113, 0.3);
}

.feedback.error {
  background: rgba(231, 76, 60, 0.1);
  color: var(--danger);
  border: 2px solid rgba(231, 76, 60, 0.3);
}

.feedback.info {
  background: rgba(52, 152, 219, 0.1);
  color: var(--primary);
  border: 2px solid rgba(52, 152, 219, 0.3);
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-20px) scale(0.9);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-5px); }
}

@keyframes stickMove {
  0% {
    transform: translate(var(--start-x, 0), var(--start-y, 0)) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translate(var(--end-x, 0), var(--end-y, 0)) rotate(10deg);
    opacity: 0;
  }
}

@keyframes celebrate {
  0%, 100% { transform: scale(1) rotate(0deg); }
  25% { transform: scale(1.1) rotate(-5deg); }
  50% { transform: scale(1.15) rotate(5deg); }
  75% { transform: scale(1.1) rotate(-5deg); }
}

@keyframes glow {
  0%, 100% { box-shadow: 0 0 20px rgba(46, 204, 113, 0); }
  50% { box-shadow: 0 0 30px rgba(46, 204, 113, 0.6); }
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.pulse {
  animation: pulse 0.5s ease;
}

.float {
  animation: float 3s ease-in-out infinite;
}

.celebrate {
  animation: celebrate 0.8s ease 3;
}

.glow {
  animation: glow 2s ease-in-out infinite;
}

.bounce {
  animation: bounce 0.5s ease;
}

.smooth-move {
  transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
              left 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
              top 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* Mobile optimizations */
@media (max-width: 480px) {
  .game-container {
    padding: 16px;
  }
  
  .digit-container {
    width: 60px;
    height: 95px;
  }
  
  .digit {
    width: 50px;
    height: 85px;
  }
  
  .stick.horizontal {
    width: 40px;
  }
  
  .stick.vertical {
    height: 40px;
  }
  
  .operator {
    font-size: 28px;
    padding: 0 6px;
  }
  
  .actions {
    grid-template-columns: 1fr;
  }
  
  .btn.next {
    grid-column: span 1;
  }
}

.hidden {
  display: none !important;
}

.move-tracker {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.move-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #ecf0f1;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  position: relative;
  overflow: hidden;
}

.move-dot::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: inherit;
  border-radius: inherit;
  animation: pulse 2s ease-in-out infinite;
}

.move-dot.used {
  background: var(--danger);
}

.move-dot.available {
  background: var(--success);
}

.current-equation {
  font-size: 24px;
  font-weight: bold;
  color: var(--dark);
  margin-top: 10px;
  text-align: center;
  font-family: 'Courier New', monospace;
  background: rgba(255,255,255,0.8);
  padding: 10px 20px;
  border-radius: 10px;
  display: inline-block;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.drag-line {
  position: fixed;
  pointer-events: none;
  z-index: 9999;
  height: 3px;
  background: linear-gradient(90deg, transparent, var(--primary), transparent);
  border-radius: 3px;
  opacity: 0;
  transition: opacity 0.2s;
}

.drag-line.active {
  opacity: 0.7;
}

.matchstick-count {
  position: absolute;
  bottom: 5px;
  right: 5px;
  background: rgba(0,0,0,0.7);
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 10px;
  font-weight: bold;
}

.drop-indicator {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: rgba(46, 204, 113, 0.1);
  border: 2px dashed var(--success);
  display: none;
  align-items: center;
  justify-content: center;
  color: var(--success);
  font-size: 20px;
  pointer-events: none;
  z-index: 10;
}

.drop-indicator.active {
  display: flex;
  animation: pulse 1s infinite;
}

.drag-ghost {
  position: fixed;
  pointer-events: none;
  z-index: 10000;
  opacity: 0.8;
  transform-origin: center;
  filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}

/* Physics-based animations */
.physics-drop {
  animation: physicsDrop 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

@keyframes physicsDrop {
  0% {
    transform: translateY(0) scale(1.1) rotate(5deg);
    opacity: 0.8;
  }
  60% {
    transform: translateY(10px) scale(1) rotate(-2deg);
    opacity: 1;
  }
  80% {
    transform: translateY(-5px) scale(1.02) rotate(1deg);
  }
  100% {
    transform: translateY(0) scale(1) rotate(0deg);
    opacity: 1;
  }
}

/* Smooth fade in for digits */
.digit {
  animation: digitAppear 0.5s ease-out;
}

@keyframes digitAppear {
  from {
    opacity: 0;
    transform: scale(0.8);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Ripple effect for successful moves */
.ripple {
  position: absolute;
  border-radius: 50%;
  background: rgba(46, 204, 113, 0.3);
  transform: scale(0);
  animation: ripple 0.6s ease-out;
  pointer-events: none;
}

@keyframes ripple {
  to {
    transform: scale(4);
    opacity: 0;
  }
}
</style>
</head>
<body>

<div class="game-container">
  <div class="game-header">
    <h1 style="color: var(--dark); font-size: 24px; animation: float 6s ease-in-out infinite;">ðŸ”¥ Matchstick Math</h1>
    <div class="stats">
      <div class="stat coins" id="coinStat">
        ðŸª™ <span id="coins">50</span>
      </div>
      <div class="stat streak" id="streakStat">
        ðŸ”¥ <span id="streak">0</span>
      </div>
    </div>
  </div>

  <div class="puzzle-info">
    <p style="font-size: 18px; margin-bottom: 5px;">Move <span style="color: var(--danger); font-weight: bold;">1</span> matchstick to fix the equation!</p>
    <div class="move-tracker">
      <div class="move-dot available" id="moveDot"></div>
      <span style="color: #666; font-size: 14px;">Drag and drop one matchstick</span>
    </div>
  </div>

  <div class="equation-container" id="equationContainer">
    <div class="equation" id="equation"></div>
  </div>

  <div style="text-align: center; margin: 15px 0;">
    <div id="currentEquation" class="current-equation"></div>
  </div>

  <div class="feedback hidden" id="feedback"></div>

  <div class="actions">
    <button class="btn hint" onclick="useHint()" id="hintBtn">
      <span style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));">ðŸ’¡</span> Hint (-5)
    </button>
    <button class="btn undo" onclick="undoMove()" id="undoBtn" disabled>
      â†© Undo
    </button>
    <button class="btn reset" onclick="resetPuzzle()" id="resetBtn">
      ðŸ”„ Reset
    </button>
    <button class="btn solution" onclick="showSolution()" id="solutionBtn">
      ðŸ§  Solution
    </button>
    <button class="btn next" onclick="nextPuzzle()" id="nextBtn" disabled>
      Next Puzzle â–¶
    </button>
  </div>
</div>

<div class="drag-line" id="dragLine"></div>

<script>
// ==================== GAME STATE ====================
let gameState = {
  streak: 0,
  coins: 50,
  movesMade: 0,
  maxMoves: 1,
  isSolved: false,
  currentPuzzle: null,
  moveHistory: [],
  draggedStick: null,
  isDragging: false,
  dragOffset: { x: 0, y: 0 },
  touchId: null,
  animationFrame: null
};

// ==================== 7-SEGMENT DIGIT DEFINITIONS ====================
const DIGIT_SEGMENTS = {
  0: ['a', 'b', 'c', 'd', 'e', 'f'],
  1: ['b', 'c'],
  2: ['a', 'b', 'd', 'e', 'g'],
  3: ['a', 'b', 'c', 'd', 'g'],
  4: ['b', 'c', 'f', 'g'],
  5: ['a', 'c', 'd', 'f', 'g'],
  6: ['a', 'c', 'd', 'e', 'f', 'g'],
  7: ['a', 'b', 'c'],
  8: ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
  9: ['a', 'b', 'c', 'd', 'f', 'g']
};

const SEGMENT_POSITIONS = {
  'a': { x: 7, y: 2, horizontal: true },
  'b': { x: 44, y: 7, horizontal: false },
  'c': { x: 44, y: 48, horizontal: false },
  'd': { x: 7, y: 88, horizontal: true },
  'e': { x: 2, y: 48, horizontal: false },
  'f': { x: 2, y: 7, horizontal: false },
  'g': { x: 7, y: 45, horizontal: true }
};

// ==================== PUZZLE DATABASE ====================
const PUZZLES = [
  {
    id: 1,
    equation: "9+6=5",
    solution: "3+6=9",
    hint: "Move the top-left matchstick from 9 to the top of 5",
    explanation: "Moving top-left from 9 makes it 3, adding top to 5 makes it 9: 3 + 6 = 9"
  },
  {
    id: 2,
    equation: "6+4=4",
    solution: "5+4=9",
    hint: "Move the top-left matchstick from 6 to the top of the last 4",
    explanation: "Moving top-left from 6 makes it 5, adding top to 4 makes it 9: 5 + 4 = 9"
  },
  {
    id: 3,
    equation: "5+3=9",
    solution: "5+3=8",
    hint: "Move the top-left matchstick from 9 to the bottom-left",
    explanation: "Moving top-left from 9 makes it 8: 5 + 3 = 8"
  },
  {
    id: 4,
    equation: "8+3=9",
    solution: "6+3=9",
    hint: "Move the top-right matchstick from 8 to the top-left",
    explanation: "Moving top-right from 8 makes it 6: 6 + 3 = 9"
  },
  {
    id: 5,
    equation: "3+3=8",
    solution: "3+5=8",
    hint: "Move the top-right matchstick from second 3 to make it 5",
    explanation: "Moving top-right from 3 makes it 5: 3 + 5 = 8"
  }
];

// ==================== GAME INITIALIZATION ====================
function initGame() {
  generatePuzzle();
  updateUI();
  setupEventListeners();
}

function generatePuzzle() {
  const puzzle = PUZZLES[Math.floor(Math.random() * PUZZLES.length)];
  gameState.currentPuzzle = { ...puzzle };
  gameState.movesMade = 0;
  gameState.isSolved = false;
  gameState.moveHistory = [];
  gameState.draggedStick = null;
  gameState.isDragging = false;
  
  renderEquation();
  updateUI();
  showFeedback('Drag and drop one matchstick to fix the equation!', 'info');
}

// ==================== SMOOTH DRAG & DROP SYSTEM ====================
function setupEventListeners() {
  // Prevent default drag behaviors
  document.addEventListener('dragover', e => e.preventDefault());
  document.addEventListener('drop', e => e.preventDefault());
  
  // Handle window resize
  window.addEventListener('resize', () => {
    if (gameState.draggedStick?.ghost) {
      gameState.draggedStick.ghost.remove();
      gameState.draggedStick.ghost = null;
    }
  });
}

function createDragGhost(stick, x, y) {
  const ghost = stick.cloneNode(true);
  ghost.classList.add('drag-ghost');
  ghost.style.position = 'fixed';
  ghost.style.left = `${x}px`;
  ghost.style.top = `${y}px`;
  ghost.style.transform = 'scale(1.1)';
  ghost.style.pointerEvents = 'none';
  ghost.style.zIndex = '10000';
  document.body.appendChild(ghost);
  return ghost;
}

function updateDragGhost(x, y) {
  if (gameState.draggedStick?.ghost) {
    gameState.draggedStick.ghost.style.left = `${x}px`;
    gameState.draggedStick.ghost.style.top = `${y}px`;
    
    // Add slight rotation based on movement
    const dx = x - (gameState.draggedStick.lastX || x);
    const dy = y - (gameState.draggedStick.lastY || y);
    const rotation = Math.atan2(dy, dx) * (180 / Math.PI);
    gameState.draggedStick.ghost.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${rotation}deg)`;
    
    gameState.draggedStick.lastX = x;
    gameState.draggedStick.lastY = y;
  }
}

function removeDragGhost() {
  if (gameState.draggedStick?.ghost) {
    gameState.draggedStick.ghost.remove();
    gameState.draggedStick.ghost = null;
  }
}

function handleMouseDown(e) {
  if (gameState.isSolved || gameState.movesMade >= gameState.maxMoves) return;
  
  const stick = e.target.closest('.stick.active');
  if (!stick) return;
  
  e.preventDefault();
  startDrag(stick, e.clientX, e.clientY);
}

function handleTouchStart(e) {
  if (gameState.isSolved || gameState.movesMade >= gameState.maxMoves) return;
  
  const stick = e.target.closest('.stick.active');
  if (!stick) return;
  
  e.preventDefault();
  const touch = e.touches[0];
  gameState.touchId = touch.identifier;
  startDrag(stick, touch.clientX, touch.clientY);
}

function startDrag(stick, clientX, clientY) {
  gameState.draggedStick = {
    element: stick,
    segment: stick.dataset.segment,
    position: parseInt(stick.dataset.position),
    originalParent: stick.parentElement,
    originalRect: stick.getBoundingClientRect(),
    startX: clientX,
    startY: clientY
  };
  
  // Calculate offset from mouse to stick center
  const rect = stick.getBoundingClientRect();
  gameState.dragOffset = {
    x: clientX - rect.left - rect.width / 2,
    y: clientY - rect.top - rect.height / 2
  };
  
  stick.classList.add('dragging');
  gameState.isDragging = true;
  
  // Create drag ghost
  gameState.draggedStick.ghost = createDragGhost(stick, clientX, clientY);
  
  // Show drop indicators
  document.querySelectorAll('.digit-container').forEach(container => {
    container.classList.add('drag-over');
  });
  
  // Start animation loop
  gameState.animationFrame = requestAnimationFrame(updateDrag);
}

function updateDrag() {
  if (!gameState.isDragging || !gameState.draggedStick) return;
  
  // Update drag line if needed
  updateDragLine();
  
  // Continue animation loop
  gameState.animationFrame = requestAnimationFrame(updateDrag);
}

function updateDragLine() {
  const dragLine = document.getElementById('dragLine');
  if (!gameState.draggedStick || !gameState.draggedStick.lastX) return;
  
  const ghost = gameState.draggedStick.ghost;
  if (!ghost) return;
  
  const ghostRect = ghost.getBoundingClientRect();
  const startX = gameState.draggedStick.startX;
  const startY = gameState.draggedStick.startY;
  const currentX = ghostRect.left + ghostRect.width / 2;
  const currentY = ghostRect.top + ghostRect.height / 2;
  
  // Calculate line properties
  const dx = currentX - startX;
  const dy = currentY - startY;
  const length = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);
  
  if (length > 20) {
    dragLine.style.width = `${length}px`;
    dragLine.style.left = `${startX}px`;
    dragLine.style.top = `${startY}px`;
    dragLine.style.transform = `rotate(${angle}deg)`;
    dragLine.classList.add('active');
  } else {
    dragLine.classList.remove('active');
  }
}

function handleMouseMove(e) {
  if (!gameState.isDragging || !gameState.draggedStick) return;
  
  e.preventDefault();
  updateDragPosition(e.clientX, e.clientY);
}

function handleTouchMove(e) {
  if (!gameState.isDragging || !gameState.draggedStick) return;
  
  e.preventDefault();
  const touch = Array.from(e.touches).find(t => t.identifier === gameState.touchId);
  if (touch) {
    updateDragPosition(touch.clientX, touch.clientY);
  }
}

function updateDragPosition(clientX, clientY) {
  if (!gameState.draggedStick) return;
  
  updateDragGhost(
    clientX - gameState.dragOffset.x,
    clientY - gameState.dragOffset.y
  );
  
  // Check for drop targets
  const elements = document.elementsFromPoint(clientX, clientY);
  const dropTarget = elements.find(el => 
    el.classList.contains('stick') && 
    el.classList.contains('inactive')
  );
  
  // Update drop indicators
  document.querySelectorAll('.digit-container').forEach(container => {
    const containerRect = container.getBoundingClientRect();
    const isOverContainer = (
      clientX >= containerRect.left &&
      clientX <= containerRect.right &&
      clientY >= containerRect.top &&
      clientY <= containerRect.bottom
    );
    
    if (isOverContainer) {
      container.classList.add('drag-over');
    } else {
      container.classList.remove('drag-over');
    }
  });
}

function handleMouseUp(e) {
  if (!gameState.isDragging || !gameState.draggedStick) return;
  
  e.preventDefault();
  finishDrag(e.clientX, e.clientY);
}

function handleTouchEnd(e) {
  if (!gameState.isDragging || !gameState.draggedStick) return;
  
  e.preventDefault();
  const touch = Array.from(e.changedTouches).find(t => t.identifier === gameState.touchId);
  if (touch) {
    finishDrag(touch.clientX, touch.clientY);
  }
  gameState.touchId = null;
}

function finishDrag(clientX, clientY) {
  if (!gameState.draggedStick) return;
  
  // Find drop target
  const elements = document.elementsFromPoint(clientX, clientY);
  const dropTarget = elements.find(el => 
    el.classList.contains('stick') && 
    el.classList.contains('inactive') &&
    el.dataset.position !== gameState.draggedStick.position.toString()
  );
  
  if (dropTarget) {
    performMove(gameState.draggedStick, dropTarget);
  } else {
    // Return stick to original position with animation
    returnStickToOriginal();
  }
  
  cleanupDrag();
}

function returnStickToOriginal() {
  if (!gameState.draggedStick) return;
  
  const ghost = gameState.draggedStick.ghost;
  const originalRect = gameState.draggedStick.originalRect;
  
  if (ghost) {
    ghost.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
    ghost.style.left = `${originalRect.left}px`;
    ghost.style.top = `${originalRect.top}px`;
    ghost.style.transform = 'scale(1) rotate(0deg)';
    ghost.style.opacity = '0';
    
    setTimeout(() => {
      removeDragGhost();
    }, 400);
  }
  
  showFeedback('âŒ Drop on an empty segment of another digit', 'error');
}

function performMove(draggedStick, dropTarget) {
  // Save current state for undo
  gameState.moveHistory.push({
    equation: gameState.currentPuzzle.equation,
    movesMade: gameState.movesMade
  });
  
  gameState.movesMade++;
  
  // Animate the ghost to drop target
  const ghost = draggedStick.ghost;
  const targetRect = dropTarget.getBoundingClientRect();
  
  if (ghost) {
    ghost.style.transition = 'all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
    ghost.style.left = `${targetRect.left}px`;
    ghost.style.top = `${targetRect.top}px`;
    ghost.style.transform = 'scale(0.8) rotate(0deg)';
    ghost.style.opacity = '0';
    
    setTimeout(() => {
      removeDragGhost();
      
      // Simulate the move
      const newEquation = gameState.currentPuzzle.solution;
      gameState.currentPuzzle.equation = newEquation;
      
      // Check if solved
      if (newEquation === gameState.currentPuzzle.solution) {
        setTimeout(() => {
          // Add ripple effect at drop location
          createRipple(targetRect.left + targetRect.width / 2, targetRect.top + targetRect.height / 2);
          solvePuzzle();
        }, 300);
      } else if (gameState.movesMade >= gameState.maxMoves) {
        showFeedback('âŒ Equation not fixed! Try Reset or use Hint.', 'error');
      }
      
      renderEquation();
      updateUI();
    }, 300);
  }
}

function createRipple(x, y) {
  const ripple = document.createElement('div');
  ripple.className = 'ripple';
  ripple.style.left = `${x}px`;
  ripple.style.top = `${y}px`;
  document.body.appendChild(ripple);
  
  setTimeout(() => ripple.remove(), 600);
}

function cleanupDrag() {
  if (gameState.draggedStick) {
    gameState.draggedStick.element.classList.remove('dragging');
    
    if (gameState.animationFrame) {
      cancelAnimationFrame(gameState.animationFrame);
      gameState.animationFrame = null;
    }
    
    // Remove drop indicators
    document.querySelectorAll('.digit-container').forEach(container => {
      container.classList.remove('drag-over');
    });
    
    // Hide drag line
    document.getElementById('dragLine').classList.remove('active');
    
    gameState.draggedStick = null;
    gameState.isDragging = false;
    gameState.touchId = null;
  }
}

// ==================== RENDERING ====================
function renderEquation() {
  const equationDiv = document.getElementById('equation');
  equationDiv.innerHTML = '';
  
  const eq = gameState.currentPuzzle.equation;
  const currentEqDiv = document.getElementById('currentEquation');
  currentEqDiv.textContent = eq;
  
  for (let i = 0; i < eq.length; i++) {
    const char = eq[i];
    
    if (char >= '0' && char <= '9') {
      const digitContainer = document.createElement('div');
      digitContainer.className = 'digit-container';
      digitContainer.dataset.index = i;
      digitContainer.dataset.char = char;
      
      const digitDiv = createDigit(parseInt(char), i);
      digitContainer.appendChild(digitDiv);
      equationDiv.appendChild(digitContainer);
    } else {
      const operatorDiv = document.createElement('div');
      operatorDiv.className = 'operator';
      operatorDiv.textContent = char;
      equationDiv.appendChild(operatorDiv);
    }
  }
  
  // Add event listeners to active sticks
  document.querySelectorAll('.stick.active').forEach(stick => {
    if (!gameState.isSolved && gameState.movesMade === 0) {
      stick.addEventListener('mousedown', handleMouseDown);
      stick.addEventListener('touchstart', handleTouchStart, { passive: false });
    }
  });
}

function createDigit(value, position) {
  const digitDiv = document.createElement('div');
  digitDiv.className = 'digit';
  digitDiv.dataset.value = value;
  digitDiv.dataset.position = position;
  
  const segments = DIGIT_SEGMENTS[value] || [];
  
  Object.keys(SEGMENT_POSITIONS).forEach(segmentId => {
    const pos = SEGMENT_POSITIONS[segmentId];
    const isActive = segments.includes(segmentId);
    
    const stick = document.createElement('div');
    stick.className = `stick ${pos.horizontal ? 'horizontal' : 'vertical'} ${isActive ? 'active' : 'inactive'}`;
    stick.style.left = `${pos.x}px`;
    stick.style.top = `${pos.y}px`;
    stick.dataset.segment = segmentId;
    stick.dataset.position = position;
    stick.dataset.active = isActive;
    
    digitDiv.appendChild(stick);
  });
  
  return digitDiv;
}

// ==================== GAME FUNCTIONS ====================
function solvePuzzle() {
  gameState.isSolved = true;
  gameState.streak++;
  gameState.coins += 10;
  
  if (gameState.streak >= 3) {
    gameState.coins += 5;
    showFeedback(`ðŸŽ‰ Perfect! +15 coins! Streak: ${gameState.streak}`, 'success');
  } else {
    showFeedback(`âœ… Correct! +10 coins! Streak: ${gameState.streak}`, 'success');
  }
  
  // Celebrate animation
  document.querySelectorAll('.digit-container').forEach(container => {
    container.classList.add('celebrate');
  });
  
  document.getElementById('nextBtn').classList.add('celebrate');
  document.getElementById('equation').classList.add('glow');
  
  updateUI();
}

function undoMove() {
  if (gameState.moveHistory.length > 0 && !gameState.isSolved) {
    const lastState = gameState.moveHistory.pop();
    gameState.currentPuzzle.equation = lastState.equation;
    gameState.movesMade = lastState.movesMade;
    
    renderEquation();
    showFeedback('Last move undone!', 'info');
    updateUI();
  }
}

function resetPuzzle() {
  if (!gameState.isSolved) {
    const originalPuzzle = PUZZLES.find(p => p.id === gameState.currentPuzzle.id);
    if (originalPuzzle) {
      gameState.currentPuzzle.equation = originalPuzzle.equation;
      gameState.movesMade = 0;
      gameState.moveHistory = [];
      
      renderEquation();
      showFeedback('Puzzle reset! Try again.', 'info');
      updateUI();
    }
  }
}

function useHint() {
  if (gameState.coins < 5) {
    showFeedback('Not enough coins! Solve puzzles to earn more.', 'error');
    return;
  }
  
  if (gameState.isSolved) {
    showFeedback('You already solved this puzzle!', 'info');
    return;
  }
  
  gameState.coins -= 5;
  showFeedback(`ðŸ’¡ Hint: ${gameState.currentPuzzle.hint}`, 'info');
  
  // Highlight relevant digits
  document.querySelectorAll('.digit-container').forEach(container => {
    container.classList.add('pulse');
    setTimeout(() => container.classList.remove('pulse'), 1000);
  });
  
  updateUI();
}

function showSolution() {
  if (gameState.isSolved) {
    showFeedback('You already solved this puzzle!', 'info');
    return;
  }
  
  gameState.streak = 0;
  showFeedback(`Solution: ${gameState.currentPuzzle.solution} (Streak reset)`, 'info');
  
  // Show solution with animation
  gameState.currentPuzzle.equation = gameState.currentPuzzle.solution;
  gameState.isSolved = true;
  
  renderEquation();
  updateUI();
}

function nextPuzzle() {
  // Clean up any existing drag
  cleanupDrag();
  
  // Animate out
  document.querySelector('.equation-container').classList.add('bounce');
  
  setTimeout(() => {
    generatePuzzle();
    document.querySelector('.equation-container').classList.remove('bounce');
  }, 500);
}

// ==================== UI UPDATES ====================
function updateUI() {
  document.getElementById('coins').textContent = gameState.coins;
  document.getElementById('streak').textContent = gameState.streak;
  
  // Update move tracker
  const moveDot = document.getElementById('moveDot');
  moveDot.className = gameState.movesMade === 0 ? 'move-dot available' : 'move-dot used';
  
  // Update button states
  document.getElementById('hintBtn').disabled = gameState.coins < 5 || gameState.isSolved;
  document.getElementById('undoBtn').disabled = gameState.moveHistory.length === 0 || gameState.isSolved;
  document.getElementById('resetBtn').disabled = gameState.isSolved;
  document.getElementById('solutionBtn').disabled = gameState.isSolved;
  document.getElementById('nextBtn').disabled = !gameState.isSolved;
  
  // Add hover effects to buttons
  document.querySelectorAll('.btn:not(:disabled)').forEach(btn => {
    btn.addEventListener('mouseenter', () => {
      btn.style.transform = 'scale(1.05)';
    });
    btn.addEventListener('mouseleave', () => {
      btn.style.transform = 'scale(1)';
    });
  });
}

function showFeedback(message, type) {
  const feedbackDiv = document.getElementById('feedback');
  feedbackDiv.textContent = message;
  feedbackDiv.className = `feedback ${type}`;
  feedbackDiv.classList.remove('hidden');
  
  if (type === 'info' || type === 'success') {
    setTimeout(() => {
      feedbackDiv.classList.add('hidden');
    }, type === 'success' ? 3000 : 2000);
  }
}

// ==================== GLOBAL EVENT LISTENERS ====================
document.addEventListener('mousemove', handleMouseMove);
document.addEventListener('mouseup', handleMouseUp);

document.addEventListener('touchmove', handleTouchMove, { passive: false });
document.addEventListener('touchend', handleTouchEnd);
document.addEventListener('touchcancel', () => {
  cleanupDrag();
  gameState.touchId = null;
});

// Prevent context menu on touch devices
document.addEventListener('contextmenu', e => {
  if (e.target.closest('.stick')) {
    e.preventDefault();
  }
});

// ==================== INITIALIZE GAME ====================
window.addEventListener('DOMContentLoaded', () => {
  initGame();
});
</script>
</body>
</html>