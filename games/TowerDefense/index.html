<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tower Defense — Build defenses against enemy waves</title>
<style>
  :root{--bg:#0b1020;--panel:#0f1724;--accent:#7dd3fc;--muted:#9aa4b2}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;color:#e6eef6;background:linear-gradient(180deg,#071028 0%, #081225 60%);}
  .wrap{display:grid;grid-template-columns:1fr 340px;gap:18px;padding:20px;box-sizing:border-box;height:100vh}
  canvas{background:linear-gradient(180deg,#123 0%, #092 100%);border-radius:12px;box-shadow:0 8px 30px rgba(3,6,20,.6);width:100%;height:100%;display:block}
  .panel{background:var(--panel);border-radius:12px;padding:16px;color:#dbe9ff;display:flex;flex-direction:column;gap:12px}
  h1{margin:0;font-size:18px;color:var(--accent)}
  .stat{display:flex;justify-content:space-between;padding:8px 10px;background:rgba(255,255,255,.03);border-radius:8px}
  .row{display:flex;gap:8px}
  .tower-btn{flex:1;padding:10px;border-radius:8px;background:rgba(255,255,255,.02);cursor:pointer;border:1px solid rgba(255,255,255,.03);text-align:center}
  .tower-btn.disabled{opacity:.45;cursor:not-allowed}
  .mini{font-size:12px;color:var(--muted)}
  .log{flex:1;background:rgba(255,255,255,.02);padding:10px;border-radius:8px;overflow:auto;font-size:13px}
  .controls{display:flex;gap:8px}
  button{background:linear-gradient(180deg,#0f1724,#0b1220);color:#cfeeff;border:1px solid rgba(255,255,255,.04);padding:8px 10px;border-radius:8px;cursor:pointer}
  footer{font-size:12px;color:var(--muted);text-align:center}
  .selected{outline:2px solid rgba(125,211,252,.18);box-shadow:0 4px 20px rgba(125,211,252,.06)}
  .hud{display:flex;flex-direction:column;gap:6px}
</style>
</head>
<body>
<div class="wrap">
  <div style="display:flex;flex-direction:column;gap:12px">
    <canvas id="gameCanvas"></canvas>
    <div style="display:flex;gap:12px">
      <div style="flex:1;background:rgba(255,255,255,.02);padding:10px;border-radius:10px;color:#dbe9ff">Tips: Place towers near bends. Cheaper towers rapid-fire, sniper towers long-range. Use upgrades!</div>
      <div style="width:220px;background:rgba(255,255,255,.02);padding:10px;border-radius:10px;color:#dbe9ff">Level: <span id="levelNum">1</span></div>
    </div>
  </div>

  <div class="panel">
    <h1>Tower Defense</h1>
    <div class="stat"><div>Money</div><div id="money">100</div></div>
    <div class="stat"><div>Lives</div><div id="lives">20</div></div>
    <div class="stat"><div>Wave</div><div id="wave">0 / 5</div></div>

    <div class="hud">
      <div class="mini">Build Towers</div>
      <div class="row">
        <div id="btnBasic" class="tower-btn selected"><strong>Basic</strong><div class="mini">Cost 50 · Rapid</div></div>
        <div id="btnSniper" class="tower-btn"><strong>Sniper</strong><div class="mini">Cost 100 · Long</div></div>
        <div id="btnSlow" class="tower-btn"><strong>Frost</strong><div class="mini">Cost 80 · Slow</div></div>
      </div>
      <div class="mini">Click on map to place tower. Hold Shift and click to upgrade if your tower is there.</div>

      <div class="mini">Game Controls</div>
      <div class="controls">
        <button id="startWave">Start Wave</button>
        <button id="speedBtn">Speed x1</button>
        <button id="sellMode">Sell Mode: Off</button>
      </div>

      <div class="mini">Towers Placed</div>
      <div id="towerList" style="display:flex;flex-direction:column;gap:6px"></div>

      <div class="mini">Event Log</div>
      <div class="log" id="log"></div>
    </div>

    <footer>Made with ❤️ — single-file HTML5 game. Press R to restart level.</footer>
  </div>
</div>

<script>
// ---- BASIC TOWER DEFENSE GAME (single file) ----
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;
function resize(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize',resize);
resize();

// Game state
let money = 100, lives = 20, currentWave = 0, wavesPerLevel = 5, level=1;
let gameSpeed = 1;
let selling = false;
const logEl = document.getElementById('log');
function log(text){ const p = document.createElement('div'); p.textContent = text; logEl.prepend(p); }

const ui = {
  money: document.getElementById('money'),
  lives: document.getElementById('lives'),
  wave: document.getElementById('wave'),
  levelNum: document.getElementById('levelNum'),
  speedBtn: document.getElementById('speedBtn'),
  startWave: document.getElementById('startWave'),
  sellMode: document.getElementById('sellMode')
}
function updateUI(){ ui.money.textContent = money; ui.lives.textContent = lives; ui.wave.textContent = currentWave + ' / ' + wavesPerLevel; ui.levelNum.textContent = level; ui.sellMode.textContent = 'Sell Mode: ' + (selling? 'On':'Off'); }
updateUI();

// Map path (hard-coded path points)
const map = {w: 1200, h: 700};
const path = [
  {x:60,y:80},{x:60,y:300},{x:260,y:300},{x:260,y:120},{x:460,y:120},{x:460,y:420},{x:760,y:420},{x:760,y:80},{x:1080,y:80}
];

// Entities
let enemies = [], towers = [], projectiles = [], wavesQueue = [], waveActive=false;

function distance(a,b){const dx=a.x-b.x,dy=a.y-b.y;return Math.sqrt(dx*dx+dy*dy);} 

// Enemy template
class Enemy{
  constructor(hp,speed, reward){ this.maxHp = hp; this.hp=hp; this.speed = speed; this.reward = reward; this.pathIndex=0; this.x=path[0].x; this.y=path[0].y; this.progress=0; this.slow=0; }
  update(dt){
    if(this.pathIndex>=path.length-1) return;
    const target = path[this.pathIndex+1];
    const dirx = target.x - this.x; const diry = target.y - this.y; const dist = Math.sqrt(dirx*dirx+diry*diry);
    if(dist < 1){ this.pathIndex++; return; }
    const sp = this.speed * (this.slow?0.45:1) * dt;
    this.x += dirx/dist * sp; this.y += diry/dist * sp;
  }
  reachedEnd(){ return this.pathIndex >= path.length-1 && distance(this, path[path.length-1]) < 6; }
}

// Tower types
const TOWER_TYPES = {
  basic: {cost:50, range:90, rate:1.2, bulletSpeed:400, dmg:18, name:'Basic'},
  sniper: {cost:100, range:220, rate:1.8, bulletSpeed:650, dmg:60, name:'Sniper'},
  slow: {cost:80, range:120, rate:1.4, bulletSpeed:300, dmg:8, slow:true, name:'Frost'}
}

class Tower{
  constructor(x,y,type){ this.x=x; this.y=y; this.type = type; this.level=1; this.cooldown=0; }
  get spec(){ return TOWER_TYPES[this.type]; }
  update(dt){ this.cooldown -= dt; if(this.cooldown<=0){ this.tryShoot(); }}
  tryShoot(){
    // find closest target in range
    let best=null; let bestD=1e9;
    for(const e of enemies){ const d = distance(this,e); if(d <= this.spec.range && e.hp>0){ if(d < bestD){ bestD=d; best=e; } }}
    if(best){ this.fireAt(best); this.cooldown = 1/this.spec.rate / (1+ (this.level-1)*0.18) ; }
  }
  fireAt(target){
    const dmg = Math.round(this.spec.dmg * (1 + (this.level-1)*0.5));
    projectiles.push({x:this.x,y:this.y,tx:target,spd:this.spec.bulletSpeed, dmg, slow:this.spec.slow, from:this});
  }
  upgrade(){ const upCost = Math.floor(this.spec.cost * (0.9 + this.level*0.6)); if(money >= upCost){ money -= upCost; this.level++; log('Upgraded tower to L' + this.level); updateUI(); } else { log('Not enough money to upgrade'); }}
  sell(){ const ret = Math.floor(this.spec.cost * (0.6 + (this.level-1)*0.2)); money += ret; towers = towers.filter(t=>t!==this); log('Tower sold for ' + ret); updateUI(); }
}

function placeTower(x,y,type){ // ensure not on path or overlapped
  // disallow placing near path line
  for(let i=0;i<path.length-1;i++){
    // distance to segment
    const a = path[i], b = path[i+1];
    const l2 = (b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y);
    let t = ((x-a.x)*(b.x-a.x) + (y-a.y)*(b.y-a.y))/l2;
    t = Math.max(0,Math.min(1,t));
    const projx = a.x + t*(b.x-a.x); const projy = a.y + t*(b.y-a.y);
    const d = Math.hypot(x-projx,y-projy);
    if(d < 40) return false; // too close to path
  }
  // disallow overlap with existing towers
  for(const t of towers) if(Math.hypot(t.x-x,t.y-y) < 40) return false;
  const spec = TOWER_TYPES[type];
  if(money < spec.cost) { log('Not enough money'); return false; }
  money -= spec.cost; towers.push(new Tower(x,y,type)); updateUI(); log('Placed ' + spec.name + ' tower'); return true;
}

// Wave generation
function generateWave(n, baseHp=30, speed=40, reward=8){ const arr=[]; for(let i=0;i<n;i++){ arr.push(()=> new Enemy(Math.round(baseHp*(1+Math.floor(i/5)*0.2)), speed, reward)); } return arr; }
function prepareNextWaves(){ wavesQueue = [];
  for(let i=0;i<wavesPerLevel;i++){
    const size = 4 + i*3 + level*1; const baseHp = 20 + level*12 + i*10; const speed = 30 + Math.min(40, level*3);
    wavesQueue.push({spawns: generateWave(size, baseHp, speed, Math.floor(baseHp/6)), interval: 900});
  }
}
prepareNextWaves();

// Game loop
let last = performance.now();
function gameLoop(now){ const rawdt = (now - last); last = now; const dt = rawdt/1000 * gameSpeed;
  // update
  if(waveActive && wavesQueue.length){
    const w = wavesQueue[0]; if(!w.timer) w.timer=0; w.timer += rawdt * gameSpeed;
    if(w.timer >= w.interval){ // spawn one enemy
      const spawnFunc = w.spawns.shift(); if(spawnFunc){ enemies.push(spawnFunc()); w.timer = 0; }
      if(w.spawns.length===0){ wavesQueue.shift(); }
    }
  }
  // update enemies
  for(const e of enemies) e.update(dt);
  // projectiles
  for(const p of projectiles){ const t = p.tx; const dirx = t.x - p.x; const diry = t.y - p.y; const d = Math.hypot(dirx,diry);
    if(d < 6 || t.hp <= 0){ // apply damage
      if(t.hp>0){ t.hp -= p.dmg; if(p.slow) t.slow = 1.0; if(t.hp <=0){ money += t.reward; log('Enemy killed +'+t.reward); } }
      p._remove = true; continue;
    }
    const move = Math.min(p.spd * dt, d);
    p.x += dirx/d * move; p.y += diry/d * move;
  }
  projectiles = projectiles.filter(p=>!p._remove);

  // towers
  for(const t of towers) t.update(dt);

  // remove enemies that reached end or died
  for(const e of [...enemies]){
    if(e.reachedEnd()){ lives--; enemies.splice(enemies.indexOf(e),1); log('An enemy reached the base! -1 life'); updateUI(); }
    else if(e.hp <= 0){ enemies.splice(enemies.indexOf(e),1); updateUI(); }
    // decay slow
    if(e.slow){ e.slow -= dt*0.8; if(e.slow <= 0) e.slow = 0; }
  }

  // check wave end
  if(waveActive && enemies.length===0 && wavesQueue.length===0){ waveActive=false; currentWave = wavesPerLevel; updateUI(); log('Level cleared! Press Start Wave to continue'); }

  // render
  render();
  // game over
  if(lives <= 0){ resetLevel(); }

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

function resetLevel(){ log('You lost. Restarting level.'); money = 100; lives = 20; enemies=[]; towers=[]; projectiles=[]; waveActive=false; currentWave=0; prepareNextWaves(); updateUI(); }

// rendering
function drawPath(){ ctx.lineWidth = 22; ctx.lineCap='round'; ctx.strokeStyle = 'rgba(20,28,38,0.9)'; ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
  for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x, path[i].y);
  ctx.stroke();
  // center line
  ctx.lineWidth = 6; ctx.strokeStyle = 'rgba(150,200,255,0.06)'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke();
}

function render(){ // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw background grid subtle
  const ww = canvas.width/DPR, hh = canvas.height/DPR;
  ctx.save(); ctx.scale(1,1);
  // path
  drawPath();
  // towers
  for(const t of towers){ ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.arc(t.x,t.y,18,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.stroke();
    // turret
    ctx.save(); ctx.translate(t.x,t.y); ctx.rotate(Math.sin(performance.now()/600 + t.x)*0.5);
    ctx.fillStyle = '#9fe'; ctx.fillRect(-6,-10,12,22);
    ctx.restore();
    // range visual (faint)
    ctx.beginPath(); ctx.strokeStyle = 'rgba(125,211,252,0.06)'; ctx.arc(t.x,t.y,t.spec.range,0,Math.PI*2); ctx.stroke();
    // level
    ctx.fillStyle='#cfe'; ctx.font='11px sans-serif'; ctx.fillText('L'+t.level, t.x-10, t.y+30);
  }
  // enemies
  for(const e of enemies){ const healthRatio = Math.max(0,e.hp/e.maxHp);
    ctx.beginPath(); ctx.fillStyle = 'rgba(255,120,120,0.95)'; ctx.arc(e.x,e.y,10,0,Math.PI*2); ctx.fill();
    // hp bar
    ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(e.x-16,e.y-18,32,6);
    ctx.fillStyle='rgba(120,230,120,0.9)'; ctx.fillRect(e.x-16,e.y-18,32*healthRatio,6);
  }
  // projectiles
  for(const p of projectiles){ ctx.beginPath(); ctx.fillStyle='rgba(255,240,150,0.95)'; ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); }

  // path nodes
  for(const pt of path){ ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.arc(pt.x,pt.y,6,0,Math.PI*2); ctx.fill(); }
  ctx.restore();
}

// Input handling
let selectedType = 'basic';
const btnBasic = document.getElementById('btnBasic'), btnSniper=document.getElementById('btnSniper'), btnSlow=document.getElementById('btnSlow');
btnBasic.onclick = ()=>{ selectedType='basic'; setSelected(btnBasic); }
btnSniper.onclick = ()=>{ selectedType='sniper'; setSelected(btnSniper); }
btnSlow.onclick = ()=>{ selectedType='slow'; setSelected(btnSlow); }
function setSelected(el){ [btnBasic,btnSniper,btnSlow].forEach(b=>b.classList.remove('selected')); el.classList.add('selected'); }

canvas.addEventListener('click', (ev)=>{
  const rect = canvas.getBoundingClientRect(); const x = (ev.clientX - rect.left); const y = (ev.clientY - rect.top);
  if(selling){ // sell tower if clicked
    for(const t of towers){ if(Math.hypot(t.x-x,t.y-y) < 24){ t.sell(); updateUI(); return; } }
    return;
  }
  // if shift pressed -> upgrade
  if(ev.shiftKey){ for(const t of towers){ if(Math.hypot(t.x-x,t.y-y) < 24){ t.upgrade(); updateUI(); return; } } }
  // else place tower
  placeTower(x,y,selectedType);
});

// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if(e.key === 'r' || e.key === 'R'){ resetLevel(); }
});

// buttons
ui.startWave.onclick = ()=>{
  if(!waveActive){ waveActive=true; currentWave++; updateUI(); log('Wave ' + currentWave + ' started'); }
}
ui.speedBtn.onclick = ()=>{ if(gameSpeed===1){ gameSpeed=2; ui.speedBtn.textContent='Speed x2'; } else if(gameSpeed===2){ gameSpeed=4; ui.speedBtn.textContent='Speed x4'; } else { gameSpeed=1; ui.speedBtn.textContent='Speed x1'; } }
ui.sellMode.onclick = ()=>{ selling = !selling; updateUI(); }

// simple wave progression: when user clears wavesPerLevel, go to next level
setInterval(()=>{
  if(!waveActive && currentWave >= wavesPerLevel){ // level complete, prepare next
    level++; currentWave=0; money += 50 + level*10; prepareNextWaves(); updateUI(); log('Advanced to Level ' + level); }
}, 1000);

// initial demo enemies to show path
(function spawnDemo(){ const e = new Enemy(30,40,6); enemies.push(e); }());

// Save/load towers list UI
function redrawTowerList(){ const div = document.getElementById('towerList'); div.innerHTML=''; towers.forEach((t,idx)=>{
  const b = document.createElement('div'); b.style.display='flex'; b.style.justifyContent='space-between'; b.style.background='rgba(255,255,255,0.02)'; b.style.padding='6px'; b.style.borderRadius='6px';
  b.innerHTML = `<div>${t.spec.name} L${t.level}</div><div style="display:flex;gap:6px"><button data-idx='${idx}' class='upgradeBtn'>Up</button><button data-idx='${idx}' class='sellBtn'>Sell</button></div>`;
  div.appendChild(b);
});
  div.querySelectorAll('.upgradeBtn').forEach(btn=>btn.onclick = (ev)=>{ const i = +btn.dataset.idx; towers[i].upgrade(); updateUI(); redrawTowerList(); });
  div.querySelectorAll('.sellBtn').forEach(btn=>btn.onclick = (ev)=>{ const i = +btn.dataset.idx; towers[i].sell(); updateUI(); redrawTowerList(); });
}
setInterval(redrawTowerList, 700);

// visual resizing to keep map within canvas nicely
function adaptCanvasSize(){ const parent = canvas.parentElement; const pw = parent.clientWidth; const ph = parent.clientHeight; // keep aspect
  // we will map our game coords to canvas
  canvas.style.width = '100%'; canvas.style.height = '70vh'; resize(); }
adaptCanvasSize();
window.addEventListener('resize', adaptCanvasSize);

// expose some functions for debugging in console
window._td = {towers, enemies, projectiles, placeTower, resetLevel};

</script>
</body>
</html>
